"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/canvg/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   elements: () => (/* binding */ elements),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toMatrixValue: () => (/* binding */ toMatrixValue),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n\n\n\n\n\n/**\n * Options preset for `OffscreenCanvas`.\n * @param config - Preset requirements.\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\n * @returns Preset object.\n */ function offscreen() {\n    let { DOMParser: DOMParserFallback  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        async createImage (url) {\n            const response = await fetch(url);\n            const blob = await response.blob();\n            const img = await createImageBitmap(blob);\n            return img;\n        }\n    };\n    if (typeof globalThis.DOMParser !== 'undefined' || typeof DOMParserFallback === 'undefined') {\n        Reflect.deleteProperty(preset, 'DOMParser');\n    }\n    return preset;\n}\n\n/**\n * Options preset for `node-canvas`.\n * @param config - Preset requirements.\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\n * @param config.canvas - `node-canvas` exports.\n * @param config.fetch - WHATWG-compatible `fetch` function.\n * @returns Preset object.\n */ function node(param) {\n    let { DOMParser , canvas , fetch  } = param;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser,\n        fetch,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  offscreen: offscreen,\n  node: node\n});\n\n/**\n * HTML-safe compress white-spaces.\n * @param str - String to compress.\n * @returns String.\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, ' ');\n}\n/**\n * HTML-safe left trim.\n * @param str - String to trim.\n * @returns String.\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, '');\n}\n/**\n * HTML-safe right trim.\n * @param str - String to trim.\n * @returns String.\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, '');\n}\n/**\n * String to numbers array.\n * @param str - Numbers string.\n * @returns Numbers array.\n */ function toNumbers(str) {\n    const matches = str.match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm);\n    return matches ? matches.map(parseFloat) : [];\n}\n/**\n * String to matrix value.\n * @param str - Numbers string.\n * @returns Matrix value.\n */ function toMatrixValue(str) {\n    const numbers = toNumbers(str);\n    const matrix = [\n        numbers[0] || 0,\n        numbers[1] || 0,\n        numbers[2] || 0,\n        numbers[3] || 0,\n        numbers[4] || 0,\n        numbers[5] || 0\n    ];\n    return matrix;\n}\n// Microsoft Edge fix\nconst allUppercase = /^[A-Z-]+$/;\n/**\n * Normalize attribute name.\n * @param name - Attribute name.\n * @returns Normalized attribute name.\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\n * Parse external URL.\n * @param url - CSS url string.\n * @returns Parsed URL.\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    const urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url);\n    if (!urlMatch) {\n        return '';\n    }\n    return urlMatch[2] || urlMatch[3] || urlMatch[4] || '';\n}\n/**\n * Transform floats to integers in rgb colors.\n * @param color - Color to normalize.\n * @returns Normalized color.\n */ function normalizeColor(color) {\n    if (!color.startsWith('rgb')) {\n        return color;\n    }\n    let rgbParts = 3;\n    const normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>(rgbParts--) && isFloat ? String(Math.round(parseFloat(num))) : num\n    );\n    return normalizedColor;\n}\n\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nconst attributeRegex = /(\\[[^\\]]+\\])/g;\nconst idRegex = /(#[^\\s+>~.[:]+)/g;\nconst classRegex = /(\\.[^\\s+>~.[:]+)/g;\nconst pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nconst pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nconst pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nconst elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    const matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, ' '),\n        matches.length\n    ];\n}\n/**\n * Measure selector specificity.\n * @param selector - Selector to measure.\n * @returns Specificity.\n */ function getSelectorSpecificity(selector) {\n    const specificity = [\n        0,\n        0,\n        0\n    ];\n    let currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, '     $1 ').replace(/{[\\s\\S]*/gm, ' ');\n    let delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, ' ').replace(/[#.]/g, ' ');\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex) // lgtm [js/useless-assignment-to-local]\n    ;\n    specificity[2] += delta;\n    return specificity.join('');\n}\n\nconst PSEUDO_ZERO = 0.00000001;\n/**\n * Vector magnitude.\n * @param v\n * @returns Number result.\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\n * Ratio between two vectors.\n * @param u\n * @param v\n * @returns Number result.\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\n * Angle between two vectors.\n * @param u\n * @param v\n * @returns Number result.\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\n\nclass Property {\n    static empty(document) {\n        return new Property(document, 'EMPTY', '');\n    }\n    split() {\n        let separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ' ';\n        const { document , name  } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document, name, value)\n        );\n    }\n    hasValue(zeroIsValue) {\n        const value = this.value;\n        return value !== null && value !== '' && (zeroIsValue || value !== 0) && typeof value !== 'undefined';\n    }\n    isString(regexp) {\n        const { value  } = this;\n        const result = typeof value === 'string';\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        const asString = this.getString();\n        switch(true){\n            case asString.endsWith('px'):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === 'undefined' || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === 'undefined') {\n                return 0;\n            }\n            // @ts-expect-error Parse unknown value.\n            return parseFloat(def);\n        }\n        const { value  } = this;\n        // @ts-expect-error Parse unknown value.\n        let n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === 'undefined' || this.hasValue()) {\n            return typeof this.value === 'undefined' ? '' : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        let color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96 // TODO: compute?\n        ;\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, '');\n    }\n    getPixels(axisOrIsFontSize) {\n        let processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        const [axis, isFontSize] = typeof axisOrIsFontSize === 'boolean' ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        const { viewPort  } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100 * Math.min(viewPort.computeSize('x'), viewPort.computeSize('y'));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100 * Math.max(viewPort.computeSize('x'), viewPort.computeSize('y'));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100 * viewPort.computeSize('x');\n            case this.isString(/vh$/):\n                return this.getNumber() / 100 * viewPort.computeSize('y');\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1 / 72);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    const n = this.getNumber();\n                    if (processPercent && n < 1) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180);\n        }\n    }\n    getDefinition() {\n        const asString = this.getString();\n        const match = /#([^)'\"]+)/.exec(asString);\n        const name = (match === null || match === void 0 ? void 0 : match[1]) || asString;\n        return this.document.definitions[name];\n    }\n    getFillStyleDefinition(element, opacity) {\n        let def = this.getDefinition();\n        if (!def) {\n            return null;\n        }\n        // gradient\n        if (typeof def.createGradient === 'function' && 'getBoundingBox' in element) {\n            return def.createGradient(this.document.ctx, element, opacity);\n        }\n        // pattern\n        if (typeof def.createPattern === 'function') {\n            if (def.getHrefAttribute().hasValue()) {\n                const patternTransform = def.getAttribute('patternTransform');\n                def = def.getHrefAttribute().getDefinition();\n                if (def && patternTransform.hasValue()) {\n                    def.getAttribute('patternTransform', true).setValue(patternTransform.value);\n                }\n            }\n            if (def) {\n                return def.createPattern(this.document.ctx, element, opacity);\n            }\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        const key = this.getString();\n        return Property.textBaselineMapping[key] || null;\n    }\n    addOpacity(opacity) {\n        let value = this.getColor();\n        const len = value.length;\n        let commas = 0;\n        // Simulate old RGBColor version, which can't parse rgba.\n        for(let i = 0; i < len; i++){\n            if (value[i] === ',') {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            const color = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n    constructor(document, name, value){\n        this.document = document;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n}\nProperty.textBaselineMapping = {\n    'baseline': 'alphabetic',\n    'before-edge': 'top',\n    'text-before-edge': 'top',\n    'middle': 'middle',\n    'central': 'middle',\n    'after-edge': 'bottom',\n    'text-after-edge': 'bottom',\n    'ideographic': 'ideographic',\n    'alphabetic': 'alphabetic',\n    'hanging': 'hanging',\n    'mathematical': 'alphabetic'\n};\n\nclass ViewPort {\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getRoot() {\n        const [root] = this.viewPorts;\n        if (!root) {\n            return getDefault();\n        }\n        return root;\n    }\n    getCurrent() {\n        const { viewPorts  } = this;\n        const current = viewPorts[viewPorts.length - 1];\n        if (!current) {\n            return getDefault();\n        }\n        return current;\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === 'number') {\n            return d;\n        }\n        if (d === 'x') {\n            return this.width;\n        }\n        if (d === 'y') {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n    constructor(){\n        this.viewPorts = [];\n    }\n}\nViewPort.DEFAULT_VIEWPORT_WIDTH = 800;\nViewPort.DEFAULT_VIEWPORT_HEIGHT = 600;\nfunction getDefault() {\n    return {\n        width: ViewPort.DEFAULT_VIEWPORT_WIDTH,\n        height: ViewPort.DEFAULT_VIEWPORT_HEIGHT\n    };\n}\n\nclass Point {\n    static parse(point) {\n        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        const [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        const points = toNumbers(path);\n        const len = points.length;\n        const pathPoints = [];\n        for(let i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        const { x , y  } = this;\n        const xp = x * transform[0] + y * transform[2] + transform[4];\n        const yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Mouse {\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        const { screen , onClick , onMouseMove  } = this;\n        const canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        const canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        const { screen: document , events , eventElements  } = this;\n        const { style  } = document.ctx.canvas;\n        let element;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (style) {\n            style.cursor = '';\n        }\n        events.forEach((param, i)=>{\n            let { run  } = param;\n            element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        });\n        // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        const { events , eventElements  } = this;\n        events.forEach((param, i)=>{\n            let { x , y  } = param;\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        const { events , eventElements  } = this;\n        events.forEach((param, i)=>{\n            let { x , y  } = param;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        const { window , ctx  } = this.screen;\n        const point = new Point(x, y);\n        let element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window === null || window === void 0 ? void 0 : window.scrollX) {\n            point.x += window.scrollX;\n        }\n        if (window === null || window === void 0 ? void 0 : window.scrollY) {\n            point.y += window.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        const { x , y  } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: 'onclick',\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        const { x , y  } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: 'onmousemove',\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = [];\n        this.onClick = this.onClick.bind(this);\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n}\n\nconst defaultWindow = typeof window !== 'undefined' ? window : null;\nconst defaultFetch$1 = typeof fetch !== 'undefined' ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : undefined;\nclass Screen {\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        const isReadyLock = this.waits.every((_)=>_()\n        );\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = 'rgba(0,0,0,0)';\n        ctx.lineCap = 'butt';\n        ctx.lineJoin = 'miter';\n        ctx.miterLimit = 4;\n    }\n    setViewBox(param) {\n        let { document , ctx , aspectRatio , width , desiredWidth , height , desiredHeight , minX =0 , minY =0 , refX , refY , clip =false , clipX =0 , clipY =0  } = param;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        const cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, '') // ignore defer\n        ;\n        const [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(' ');\n        const align = aspectRatioAlign || 'xMidYMid';\n        const meetOrSlice = aspectRatioMeetOrSlice || 'meet';\n        // calculate scale\n        const scaleX = width / desiredWidth;\n        const scaleY = height / desiredHeight;\n        const scaleMin = Math.min(scaleX, scaleY);\n        const scaleMax = Math.max(scaleX, scaleY);\n        let finalDesiredWidth = desiredWidth;\n        let finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === 'meet') {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === 'slice') {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        const refXProp = new Property(document, 'refX', refX);\n        const refYProp = new Property(document, 'refY', refY);\n        const hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels('x'), -scaleMin * refYProp.getPixels('y'));\n        }\n        if (clip) {\n            const scaledClipX = scaleMin * clipX;\n            const scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            const isMeetMinY = meetOrSlice === 'meet' && scaleMin === scaleY;\n            const isSliceMaxY = meetOrSlice === 'slice' && scaleMax === scaleY;\n            const isMeetMinX = meetOrSlice === 'meet' && scaleMin === scaleX;\n            const isSliceMaxX = meetOrSlice === 'slice' && scaleMax === scaleX;\n            if (align.startsWith('xMid') && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2 - finalDesiredWidth / 2, 0);\n            }\n            if (align.endsWith('YMid') && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2 - finalDesiredHeight / 2);\n            }\n            if (align.startsWith('xMax') && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith('YMax') && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        }\n        // scale\n        switch(true){\n            case align === 'none':\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === 'meet':\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === 'slice':\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        }\n        // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        let { enableRedraw =false , ignoreMouse =false , ignoreAnimation =false , ignoreDimensions =false , ignoreClear =false , forceRedraw , scaleWidth , scaleHeight , offsetX , offsetY  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { mouse  } = this;\n        const frameDuration = 1000 / Screen.FRAMERATE;\n        this.isReadyLock = false;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        let now = Date.now();\n        let then = now;\n        let delta = 0;\n        const tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_0__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_0__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_0__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            const { frameDuration  } = this;\n            const shouldUpdate1 = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate\n            , false);\n            if (shouldUpdate1) {\n                return true;\n            }\n        }\n        // need update from redraw?\n        if (typeof forceRedraw === 'function' && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        }\n        // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        const { viewPort , ctx , isFirstRender  } = this;\n        const canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        }\n        const widthStyle = element.getStyle('width');\n        const heightStyle = element.getStyle('height');\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== 'number' && typeof scaleHeight !== 'number')) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels('x');\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels('y');\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        let cWidth = canvas.clientWidth || canvas.width;\n        let cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels('x');\n            cHeight = heightStyle.getPixels('y');\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === 'number') {\n            element.getAttribute('x', true).setValue(offsetX);\n        }\n        if (typeof offsetY === 'number') {\n            element.getAttribute('y', true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === 'number' || typeof scaleHeight === 'number') {\n            const viewBox = toNumbers(element.getAttribute('viewBox').getString());\n            let xRatio = 0;\n            let yRatio = 0;\n            if (typeof scaleWidth === 'number') {\n                const widthStyle = element.getStyle('width');\n                if (widthStyle.hasValue()) {\n                    xRatio = widthStyle.getPixels('x') / scaleWidth;\n                } else if (viewBox[2] && !isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === 'number') {\n                const heightStyle = element.getStyle('height');\n                if (heightStyle.hasValue()) {\n                    yRatio = heightStyle.getPixels('y') / scaleHeight;\n                } else if (viewBox[3] && !isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute('width', true).setValue(scaleWidth);\n            element.getAttribute('height', true).setValue(scaleHeight);\n            const transformStyle = element.getStyle('transform', true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1 / xRatio, \", \").concat(1 / yRatio, \")\"));\n        }\n        // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n    constructor(ctx, { fetch =defaultFetch$1 , window =defaultWindow  } = {}){\n        this.ctx = ctx;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window;\n        if (!fetch) {\n            throw new Error(\"Can't find 'fetch' in 'globalThis', please provide it via options\");\n        }\n        this.fetch = fetch;\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nScreen.FRAMERATE = 30;\nScreen.MAX_VIRTUAL_PIXELS = 30000;\n\nconst { defaultFetch  } = Screen;\nconst DefaultDOMParser = typeof DOMParser !== 'undefined' ? DOMParser : undefined;\nclass Parser {\n    async parse(resource) {\n        if (resource.startsWith('<')) {\n            return this.parseFromString(resource);\n        }\n        return this.load(resource);\n    }\n    parseFromString(xml) {\n        const parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, 'image/svg+xml'));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, 'text/xml'));\n        }\n    }\n    checkDocument(document) {\n        const parserError = document.getElementsByTagName('parsererror')[0];\n        if (parserError) {\n            throw new Error(parserError.textContent || 'Unknown parse error');\n        }\n        return document;\n    }\n    async load(url) {\n        const response = await this.fetch(url);\n        const xml = await response.text();\n        return this.parseFromString(xml);\n    }\n    constructor({ fetch =defaultFetch , DOMParser =DefaultDOMParser  } = {}){\n        if (!fetch) {\n            throw new Error(\"Can't find 'fetch' in 'globalThis', please provide it via options\");\n        }\n        if (!DOMParser) {\n            throw new Error(\"Can't find 'DOMParser' in 'globalThis', please provide it via options\");\n        }\n        this.fetch = fetch;\n        this.DOMParser = DOMParser;\n    }\n}\n\nclass Translate {\n    apply(ctx) {\n        const { x , y  } = this.point;\n        ctx.translate(x || 0, y || 0);\n    }\n    unapply(ctx) {\n        const { x , y  } = this.point;\n        ctx.translate(-1 * x || 0, -1 * y || 0);\n    }\n    applyToPoint(point) {\n        const { x , y  } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0,\n            y || 0\n        ]);\n    }\n    constructor(_, point){\n        this.type = 'translate';\n        this.point = Point.parse(point);\n    }\n}\n\nclass Rotate {\n    apply(ctx) {\n        const { cx , cy , originX , originY , angle  } = this;\n        const tx = cx + originX.getPixels('x');\n        const ty = cy + originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        const { cx , cy , originX , originY , angle  } = this;\n        const tx = cx + originX.getPixels('x');\n        const ty = cy + originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.rotate(-1 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        const { cx , cy , angle  } = this;\n        const rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0,\n            cy || 0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0,\n            -cy || 0 // -this.p.y\n        ]);\n    }\n    constructor(document, rotate, transformOrigin){\n        this.type = 'rotate';\n        const numbers = toNumbers(rotate);\n        this.angle = new Property(document, 'angle', numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n}\n\nclass Scale {\n    apply(ctx) {\n        const { scale: { x , y  } , originX , originY  } = this;\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        const { scale: { x , y  } , originX , originY  } = this;\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.scale(1 / x, 1 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        const { x , y  } = this.scale;\n        point.applyTransform([\n            x || 0,\n            0,\n            0,\n            y || 0,\n            0,\n            0\n        ]);\n    }\n    constructor(_, scale, transformOrigin){\n        this.type = 'scale';\n        const scaleSize = Point.parseScale(scale);\n        // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n}\n\nclass Matrix {\n    apply(ctx) {\n        const { originX , originY , matrix  } = this;\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        const { originX , originY , matrix  } = this;\n        const a = matrix[0];\n        const b = matrix[2];\n        const c = matrix[4];\n        const d = matrix[1];\n        const e = matrix[3];\n        const f = matrix[5];\n        const g = 0;\n        const h = 0;\n        const i = 1;\n        const det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        const tx = originX.getPixels('x');\n        const ty = originY.getPixels('y');\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n    constructor(_, matrix, transformOrigin){\n        this.type = 'matrix';\n        this.matrix = toMatrixValue(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n}\n\nclass Skew extends Matrix {\n    constructor(document, skew, transformOrigin){\n        super(document, skew, transformOrigin);\n        this.type = 'skew';\n        this.angle = new Property(document, 'angle', skew);\n    }\n}\n\nclass SkewX extends Skew {\n    constructor(document, skew, transformOrigin){\n        super(document, skew, transformOrigin);\n        this.type = 'skewX';\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\n\nclass SkewY extends Skew {\n    constructor(document, skew, transformOrigin){\n        super(document, skew, transformOrigin);\n        this.type = 'skewY';\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\n\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, ') $1').replace(/\\)(\\s?,\\s?)/g, ') ').split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    const [type = '', value = ''] = transform.split('(');\n    return [\n        type.trim(),\n        value.trim().replace(')', '')\n    ];\n}\nclass Transform {\n    static fromElement(document, element) {\n        const transformStyle = element.getStyle('transform', false, true);\n        if (transformStyle.hasValue()) {\n            const [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle('transform-origin', false, true).split();\n            if (transformOriginXProperty && transformOriginYProperty) {\n                const transformOrigin = [\n                    transformOriginXProperty,\n                    transformOriginYProperty\n                ];\n                return new Transform(document, transformStyle.getString(), transformOrigin);\n            }\n        }\n        return null;\n    }\n    apply(ctx) {\n        this.transforms.forEach((transform)=>transform.apply(ctx)\n        );\n    }\n    unapply(ctx) {\n        this.transforms.forEach((transform)=>transform.unapply(ctx)\n        );\n    }\n    // TODO: applyToPoint unused ... remove?\n    applyToPoint(point) {\n        this.transforms.forEach((transform)=>transform.applyToPoint(point)\n        );\n    }\n    constructor(document, transform1, transformOrigin){\n        this.document = document;\n        this.transforms = [];\n        const data = parseTransforms(transform1);\n        data.forEach((transform)=>{\n            if (transform === 'none') {\n                return;\n            }\n            const [type, value] = parseTransform(transform);\n            const TransformType = Transform.transformTypes[type];\n            if (TransformType) {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\n\nclass Element {\n    getAttribute(name) {\n        let createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        const attr = this.attributes[name];\n        if (!attr && createIfNotExists) {\n            const attr = new Property(this.document, name, '');\n            this.attributes[name] = attr;\n            return attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        let href;\n        for(const key in this.attributes){\n            if (key === 'href' || key.endsWith(':href')) {\n                href = this.attributes[key];\n                break;\n            }\n        }\n        return href || Property.empty(this.document);\n    }\n    getStyle(name) {\n        let createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const style = this.styles[name];\n        if (style) {\n            return style;\n        }\n        const attr = this.getAttribute(name);\n        if (attr.hasValue()) {\n            this.styles[name] = attr // move up to me to cache\n            ;\n            return attr;\n        }\n        if (!skipAncestors) {\n            const { parent  } = this;\n            if (parent) {\n                const parentStyle = parent.getStyle(name);\n                if (parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            const style = new Property(this.document, name, '');\n            this.styles[name] = style;\n            return style;\n        }\n        return Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle('display').getString() === 'none' || this.getStyle('visibility').getString() === 'hidden') {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle('mask').hasValue()) {\n            const mask = this.getStyle('mask').getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle('filter').getValue('none') !== 'none') {\n            const filter = this.getStyle('filter').getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {\n    // NO RENDER\n    }\n    applyEffects(ctx) {\n        // transform\n        const transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        }\n        // clip\n        const clipPathStyleProp = this.getStyle('clip-path', false, true);\n        if (clipPathStyleProp.hasValue()) {\n            const clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {\n    // NO RENDER\n    }\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        const child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var ref;\n        const { node  } = this;\n        if (typeof node.matches === 'function') {\n            return node.matches(selector);\n        }\n        const styleClasses = (ref = node.getAttribute) === null || ref === void 0 ? void 0 : ref.call(node, 'class');\n        if (!styleClasses || styleClasses === '') {\n            return false;\n        }\n        return styleClasses.split(' ').some((styleClass)=>\".\".concat(styleClass) === selector\n        );\n    }\n    addStylesFromStyleDefinition() {\n        const { styles , stylesSpecificity  } = this.document;\n        let styleProp;\n        for(const selector in styles){\n            if (!selector.startsWith('@') && this.matchesSelector(selector)) {\n                const style = styles[selector];\n                const specificity = stylesSpecificity[selector];\n                if (style) {\n                    for(const name in style){\n                        let existingSpecificity = this.stylesSpecificity[name];\n                        if (typeof existingSpecificity === 'undefined') {\n                            existingSpecificity = '000';\n                        }\n                        if (specificity && specificity >= existingSpecificity) {\n                            styleProp = style[name];\n                            if (styleProp) {\n                                this.styles[name] = styleProp;\n                            }\n                            this.stylesSpecificity[name] = specificity;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        const toRestore1 = ignoreStyles.reduce((toRestore, name)=>{\n            const styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            const value = styleProp.getString();\n            styleProp.setValue('');\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore1;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((param)=>{\n            let [name, value] = param;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var ref;\n        return ((ref = this.parent) === null || ref === void 0 ? void 0 : ref.children.indexOf(this)) === 0;\n    }\n    constructor(document, node, captureTextNodes = false){\n        this.document = document;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.type = '';\n        this.attributes = {};\n        this.styles = {};\n        this.stylesSpecificity = {};\n        this.animationFrozen = false;\n        this.animationFrozenValue = '';\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            return;\n        }\n        // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            const nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes[nodeName] = new Property(document, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition();\n        // add inline styles\n        if (this.getAttribute('style').hasValue()) {\n            const styles = this.getAttribute('style').getString().split(';').map((_)=>_.trim()\n            );\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                const [name, value] = style.split(':').map((_)=>_.trim()\n                );\n                if (name) {\n                    this.styles[name] = new Property(document, name, value);\n                }\n            });\n        }\n        const { definitions  } = document;\n        const id = this.getAttribute('id');\n        // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode) // ELEMENT_NODE\n                ;\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                const textNode = document.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode) // TEXT_NODE\n                    ;\n                }\n            }\n        });\n    }\n}\nElement.ignoreChildTypes = [\n    'title'\n];\n\nclass UnknownElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n    }\n}\n\nfunction wrapFontFamily(fontFamily) {\n    const trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : \"\\\"\".concat(trimmed, \"\\\"\");\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === 'undefined' ? fontFamily : fontFamily.trim().split(',').map(wrapFontFamily).join(',');\n}\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\n * @param fontStyle\n * @returns CSS font style.\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return '';\n    }\n    const targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case 'normal':\n        case 'italic':\n        case 'oblique':\n        case 'inherit':\n        case 'initial':\n        case 'unset':\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return '';\n    }\n}\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\n * @param fontWeight\n * @returns CSS font weight.\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return '';\n    }\n    const targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case 'normal':\n        case 'bold':\n        case 'lighter':\n        case 'bolder':\n        case 'inherit':\n        case 'initial':\n        case 'unset':\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return '';\n    }\n}\nclass Font {\n    static parse() {\n        let font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '', inherit = arguments.length > 1 ? arguments[1] : void 0;\n        let fontStyle = '';\n        let fontVariant = '';\n        let fontWeight = '';\n        let fontSize = '';\n        let fontFamily = '';\n        const parts = compressSpaces(font).trim().split(' ');\n        const set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== 'inherit') {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== 'inherit') {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== 'inherit') {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== 'inherit') {\n                        fontSize = part.split('/')[0] || '';\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== 'inherit') {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            // Wrap fontFamily only on nodejs and only for canvas.ctx\n            prepareFontFamily(this.fontFamily)\n        ].join(' ').trim();\n    }\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        const inheritFont = inherit ? typeof inherit === 'string' ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n}\nFont.styles = 'normal|italic|oblique|inherit';\nFont.variants = 'normal|small-caps|inherit';\nFont.weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';\n\nclass BoundingBox {\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== 'undefined') {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== 'undefined') {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, 0);\n    }\n    addY(y) {\n        this.addPoint(0, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        const { x1 , y1 , x2 , y2  } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        const b = 6 * p0 - 12 * p1 + 6 * p2;\n        const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        const c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            const t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        const b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        const t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        const t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        const cp1x = p0x + 2 / 3 * (p1x - p0x) // CP1 = QP0 + 2/3 *(QP1-QP0)\n        ;\n        const cp1y = p0y + 2 / 3 * (p1y - p0y) // CP1 = QP0 + 2/3 *(QP1-QP0)\n        ;\n        const cp2x = cp1x + 1 / 3 * (p2x - p0x) // CP2 = CP1 + 1/3 *(QP2-QP0)\n        ;\n        const cp2y = cp1y + 1 / 3 * (p2y - p0y) // CP2 = CP1 + 1/3 *(QP2-QP0)\n        ;\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        const { x1 , y1 , x2 , y2  } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n    constructor(x1 = Number.NaN, y1 = Number.NaN, x2 = Number.NaN, y2 = Number.NaN){\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n}\n\nclass RenderedElement extends Element {\n    calculateOpacity() {\n        let opacity = 1;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let element = this;\n        while(element){\n            const opacityStyle = element.getStyle('opacity', false, true) // no ancestors on style call\n            ;\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        let fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        if (!fromMeasure) {\n            // fill\n            const fillStyleProp = this.getStyle('fill');\n            const fillOpacityStyleProp = this.getStyle('fill-opacity');\n            const strokeStyleProp = this.getStyle('stroke');\n            const strokeOpacityProp = this.getStyle('stroke-opacity');\n            if (fillStyleProp.isUrlDefinition()) {\n                const fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === 'currentColor') {\n                    fillStyleProp.setValue(this.getStyle('color').getColor());\n                }\n                const fillStyle = fillStyleProp.getColor();\n                if (fillStyle !== 'inherit') {\n                    ctx.fillStyle = fillStyle === 'none' ? 'rgba(0,0,0,0)' : fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                const fillStyle = new Property(this.document, 'fill', ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = fillStyle;\n            }\n            // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                const strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === 'currentColor') {\n                    strokeStyleProp.setValue(this.getStyle('color').getColor());\n                }\n                const strokeStyle = strokeStyleProp.getString();\n                if (strokeStyle !== 'inherit') {\n                    ctx.strokeStyle = strokeStyle === 'none' ? 'rgba(0,0,0,0)' : strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                const strokeStyle = new Property(this.document, 'stroke', ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = strokeStyle;\n            }\n            const strokeWidthStyleProp = this.getStyle('stroke-width');\n            if (strokeWidthStyleProp.hasValue()) {\n                const newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            const strokeLinecapStyleProp = this.getStyle('stroke-linecap');\n            const strokeLinejoinStyleProp = this.getStyle('stroke-linejoin');\n            const strokeMiterlimitProp = this.getStyle('stroke-miterlimit');\n            // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            const strokeDasharrayStyleProp = this.getStyle('stroke-dasharray');\n            const strokeDashoffsetProp = this.getStyle('stroke-dashoffset');\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            }\n            // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            //   // ?\n            //   ctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== 'none') {\n                const gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== 'undefined') {\n                    ctx.setLineDash(gaps);\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.webkitLineDash !== 'undefined') {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.mozDash !== 'undefined' && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                const offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== 'undefined') {\n                    ctx.lineDashOffset = offset;\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.webkitLineDashOffset !== 'undefined') {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else // @ts-expect-error Handle browser prefix.\n                if (typeof ctx.mozDashOffset !== 'undefined') {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        }\n        // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== 'undefined') {\n            const fontStyleProp = this.getStyle('font');\n            const fontStyleStyleProp = this.getStyle('font-style');\n            const fontVariantStyleProp = this.getStyle('font-variant');\n            const fontWeightStyleProp = this.getStyle('font-weight');\n            const fontSizeStyleProp = this.getStyle('font-size');\n            const fontFamilyStyleProp = this.getStyle('font-family');\n            const font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : '', fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx);\n            // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.modifiedEmSizeStack = false;\n    }\n}\n\nclass TextElement extends RenderedElement {\n    setContext(ctx) {\n        let fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        const textBaseline = this.getStyle('dominant-baseline').getTextBaseline() || this.getStyle('alignment-baseline').getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== 'text') {\n            return this.getTElementBoundingBox(ctx);\n        }\n        // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        let boundingBox = null;\n        // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            const childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        const { document , parent  } = this;\n        const inheritFontSize = Font.parse(document.ctx.font).fontSize;\n        const fontSize = parent.getStyle('font-size').getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        const fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        const char = text[i];\n        let glyph;\n        if (font.isArabic) {\n            var ref;\n            const len = text.length;\n            const prevChar = text[i - 1];\n            const nextChar = text[i + 1];\n            let arabicForm = 'isolated';\n            if ((i === 0 || prevChar === ' ') && i < len - 1 && nextChar !== ' ') {\n                arabicForm = 'terminal';\n            }\n            if (i > 0 && prevChar !== ' ' && i < len - 1 && nextChar !== ' ') {\n                arabicForm = 'medial';\n            }\n            if (i > 0 && prevChar !== ' ' && (i === len - 1 || nextChar === ' ')) {\n                arabicForm = 'initial';\n            }\n            glyph = ((ref = font.arabicGlyphs[char]) === null || ref === void 0 ? void 0 : ref[arabicForm]) || font.glyphs[char];\n        } else {\n            glyph = font.glyphs[char];\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return '';\n    }\n    getTextFromNode(node) {\n        const textNode = node || this.node;\n        const childNodes = Array.from(textNode.parentNode.childNodes);\n        const index = childNodes.indexOf(textNode);\n        const lastIndex = childNodes.length - 1;\n        let text = compressSpaces(// textNode.value\n        // || textNode.text\n        textNode.textContent || '');\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== 'text') {\n            this.renderTElementChildren(ctx);\n            return;\n        }\n        // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        const { mouse  } = this.document.screen;\n        // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        const { document , parent  } = this;\n        const renderText = this.getText();\n        const customFont = parent.getStyle('font-family').getDefinition();\n        if (customFont) {\n            const { unitsPerEm  } = customFont.fontFace;\n            const ctxFont = Font.parse(document.ctx.font);\n            const fontSize = parent.getStyle('font-size').getNumber(ctxFont.fontSize);\n            const fontStyle = parent.getStyle('font-style').getString(ctxFont.fontStyle);\n            const scale = fontSize / unitsPerEm;\n            const text = customFont.isRTL ? renderText.split('').reverse().join('') : renderText;\n            const dx = toNumbers(parent.getAttribute('dx').getString());\n            const len = text.length;\n            for(let i = 0; i < len; i++){\n                const glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                const lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === 'italic') {\n                    ctx.transform(1, 0, 0.4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === 'italic') {\n                    ctx.transform(1, 0, -0.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        const { x , y  } = this;\n        // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        //   if (ctx.strokeStyle) {\n        //     ctx.strokeText(renderText, x, y);\n        //   }\n        //   if (ctx.fillStyle) {\n        //     ctx.fillText(renderText, x, y);\n        //   }\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        }\n    // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        }\n        // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        const firstElement = this.leafTexts[this.textChunkStart];\n        const textAnchor = firstElement.getStyle('text-anchor').getString('start');\n        const isRTL = false // we treat RTL like LTR\n        ;\n        let shift = 0;\n        if (textAnchor === 'start' && !isRTL || textAnchor === 'end' && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === 'end' && !isRTL || textAnchor === 'start' && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(let i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        }\n        // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i1) {\n        const child = parent.children[i1];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i1);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        const child = parent.children[i];\n        if (typeof child.measureText !== 'function') {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        const xAttr = child.getAttribute('x');\n        const yAttr = child.getAttribute('y');\n        const dxAttr = child.getAttribute('dx');\n        const dyAttr = child.getAttribute('dy');\n        const customFont = child.getStyle('font-family').getDefinition();\n        const isRTL = Boolean(customFont === null || customFont === void 0 ? void 0 : customFont.isRTL);\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute('x'));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute('y'));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute('dx'));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute('dy'));\n            }\n        }\n        const width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels('x');\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels('x');\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels('x');\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels('y');\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels('y');\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels('y');\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y;\n        // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i2) {\n        const child = parent.children[i2];\n        // not a text node?\n        if (typeof child.getBoundingBox !== 'function') {\n            return null;\n        }\n        const boundingBox = child.getBoundingBox(ctx);\n        if (boundingBox) {\n            child.children.forEach((_, i)=>{\n                const childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n                boundingBox.addBoundingBox(childBoundingBox);\n            });\n        }\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i3) {\n        const child = parent.children[i3];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        const { measureCache  } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        const renderText = this.getText();\n        const measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        const { parent  } = this;\n        const customFont = parent.getStyle('font-family').getDefinition();\n        if (customFont) {\n            const fontSize = this.getFontSize();\n            const text = customFont.isRTL ? targetText.split('').reverse().join('') : targetText;\n            const dx = toNumbers(parent.getAttribute('dx').getString());\n            const len = text.length;\n            let measure = 0;\n            for(let i = 0; i < len; i++){\n                const glyph = this.getGlyph(customFont, text, i);\n                measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== 'undefined' && !isNaN(dx[i])) {\n                    measure += dx[i];\n                }\n            }\n            return measure;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        const { width: measure  } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\n   * are only inherited from a parent to its first child.\n   * @param name - The attribute name.\n   * @returns The attribute value or null.\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        let current = this;\n        while(current instanceof TextElement && current.isFirstChild() && current.parent){\n            const parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getString('0');\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = 'text';\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.measureCache = -1;\n    }\n}\n\nclass TSpanElement extends TextElement {\n    getText() {\n        return this.text;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = 'tspan';\n        // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? '' : this.getTextFromNode();\n    }\n}\n\nclass TextNode extends TSpanElement {\n    constructor(...args){\n        super(...args);\n        this.type = 'textNode';\n    }\n}\n\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData {\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        const { i , commands  } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        const command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        let xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'x', yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'y';\n        const point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        const point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        const point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        const previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_2__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        }\n        // reflect point\n        const { current: { x: cx , y: cy  } , control: { x: ox , y: oy  }  } = this;\n        const point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            const { x , y  } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        const { points , angles  } = this;\n        // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        const { angles  } = this;\n        const len = angles.length;\n        for(let i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(let j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n    constructor(path){\n        super(path// Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, '$1')// Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, ''));\n        this.control = new Point(0, 0);\n        this.start = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n}\n\nclass PathElement extends RenderedElement {\n    path(ctx) {\n        const { pathParser  } = this;\n        const boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_ctx) {\n        return this.path();\n    }\n    getMarkers() {\n        const { pathParser  } = this;\n        const points = pathParser.getMarkerPoints();\n        const angles = pathParser.getMarkerAngles();\n        const markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]\n        );\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        const fillRuleStyleProp = this.getStyle('fill-rule');\n        if (ctx.fillStyle !== '') {\n            if (fillRuleStyleProp.getString('inherit') !== 'inherit') {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== '') {\n            if (this.getAttribute('vector-effect').getString() === 'non-scaling-stroke') {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        const markers = this.getMarkers();\n        if (markers) {\n            const markersLastIndex = markers.length - 1;\n            const markerStartStyleProp = this.getStyle('marker-start');\n            const markerMidStyleProp = this.getStyle('marker-mid');\n            const markerEndStyleProp = this.getStyle('marker-end');\n            if (markerStartStyleProp.isUrlDefinition()) {\n                const marker = markerStartStyleProp.getDefinition();\n                const [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                const marker = markerMidStyleProp.getDefinition();\n                for(let i = 1; i < markersLastIndex; i++){\n                    const [point, angle] = markers[i];\n                    marker.render(ctx, point, angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                const marker = markerEndStyleProp.getDefinition();\n                const [point, angle] = markers[markersLastIndex];\n                marker.render(ctx, point, angle);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        const point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { point  } = PathElement.pathM(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        const { current  } = pathParser;\n        const point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point  } = PathElement.pathL(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        const { current , command  } = pathParser;\n        const point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point  } = PathElement.pathH(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        const { current , command  } = pathParser;\n        const point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point  } = PathElement.pathV(pathParser);\n        const { x , y  } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        const { current  } = pathParser;\n        const point = pathParser.getPoint('x1', 'y1');\n        const controlPoint = pathParser.getAsControlPoint('x2', 'y2');\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point , controlPoint , currentPoint  } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        const { current  } = pathParser;\n        const point = pathParser.getReflectedControlPoint();\n        const controlPoint = pathParser.getAsControlPoint('x2', 'y2');\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , point , controlPoint , currentPoint  } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        const { current  } = pathParser;\n        const controlPoint = pathParser.getAsControlPoint('x1', 'y1');\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , controlPoint , currentPoint  } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        const { current  } = pathParser;\n        const controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        const currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { current , controlPoint , currentPoint  } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        const { current , command  } = pathParser;\n        let { rX , rY , xRot , lArcFlag , sweepFlag  } = command;\n        const xAxisRotation = xRot * (Math.PI / 180);\n        const currentPoint = pathParser.getAsCurrentPoint();\n        // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        const currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);\n        // adjust radii\n        const l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        }\n        // cx', cy'\n        let s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        const cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX);\n        // cx, cy\n        const centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);\n        // initial angle\n        const a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]) // θ1\n        ;\n        // angle delta\n        const u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        const v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        let ad = vectorsAngle(u, v) // Δθ\n        ;\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        const { pathParser  } = this;\n        const { currentPoint , rX , rY , sweepFlag , xAxisRotation , centp , a1 , ad  } = PathElement.pathA(pathParser);\n        // for markers\n        const dir = 1 - sweepFlag ? 1 : -1;\n        const ah = a1 + dir * (ad / 2);\n        const halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y) // TODO: this is too naive, make it better\n        ;\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            const r = rX > rY ? rX : rY;\n            const sx = rX > rY ? 1 : rX / rY;\n            const sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'path';\n        this.pathParser = new PathParser(this.getAttribute('d').getString());\n    }\n}\n\nclass SVGElement extends RenderedElement {\n    setContext(ctx) {\n        var ref;\n        const { document  } = this;\n        const { screen , window  } = document;\n        const canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if ('style' in canvas && typeof ctx.font !== 'undefined' && window && typeof window.getComputedStyle !== 'undefined') {\n            ctx.font = window.getComputedStyle(canvas).getPropertyValue('font');\n            const fontSizeProp = new Property(document, 'fontSize', Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document.rootEmSize = fontSizeProp.getPixels('y');\n                document.emSize = document.rootEmSize;\n            }\n        }\n        // create new view port\n        if (!this.getAttribute('x').hasValue()) {\n            this.getAttribute('x', true).setValue(0);\n        }\n        if (!this.getAttribute('y').hasValue()) {\n            this.getAttribute('y', true).setValue(0);\n        }\n        let { width , height  } = screen.viewPort;\n        if (!this.getStyle('width').hasValue()) {\n            this.getStyle('width', true).setValue('100%');\n        }\n        if (!this.getStyle('height').hasValue()) {\n            this.getStyle('height', true).setValue('100%');\n        }\n        if (!this.getStyle('color').hasValue()) {\n            this.getStyle('color', true).setValue('black');\n        }\n        const refXAttr = this.getAttribute('refX');\n        const refYAttr = this.getAttribute('refY');\n        const viewBoxAttr = this.getAttribute('viewBox');\n        const viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        const clip = !this.root && this.getStyle('overflow').getValue('hidden') !== 'visible';\n        let minX = 0;\n        let minY = 0;\n        let clipX = 0;\n        let clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle('width').getPixels('x');\n            height = this.getStyle('height').getPixels('y');\n            if (this.type === 'marker') {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height);\n        // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((ref = this.node.parentNode) === null || ref === void 0 ? void 0 : ref.nodeName) === 'foreignObject') && this.getStyle('transform', false, true).hasValue() && !this.getStyle('transform-origin', false, true).hasValue()) {\n            this.getStyle('transform-origin', true, true).setValue('50% 50%');\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute('x').getPixels('x'), this.getAttribute('y').getPixels('y'));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute('preserveAspectRatio').getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\n   * Resize SVG to fit in given size.\n   * @param width\n   * @param height\n   * @param preserveAspectRatio\n   */ resize(width) {\n        let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width, preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        const widthAttr = this.getAttribute('width', true);\n        const heightAttr = this.getAttribute('height', true);\n        const viewBoxAttr = this.getAttribute('viewBox');\n        const styleAttr = this.getAttribute('style');\n        const originWidth = widthAttr.getNumber(0);\n        const originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === 'string') {\n                this.getAttribute('preserveAspectRatio', true).setValue(preserveAspectRatio);\n            } else {\n                const preserveAspectRatioAttr = this.getAttribute('preserveAspectRatio');\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, '$1'));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            const widthStyle = this.getStyle('width');\n            const heightStyle = this.getStyle('height');\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'svg';\n        this.root = false;\n    }\n}\n\nclass RectElement extends PathElement {\n    path(ctx) {\n        const x = this.getAttribute('x').getPixels('x');\n        const y = this.getAttribute('y').getPixels('y');\n        const width = this.getStyle('width', false, true).getPixels('x');\n        const height = this.getStyle('height', false, true).getPixels('y');\n        const rxAttr = this.getAttribute('rx');\n        const ryAttr = this.getAttribute('ry');\n        let rx = rxAttr.getPixels('x');\n        let ry = ryAttr.getPixels('y');\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2);\n        ry = Math.min(ry, height / 2);\n        if (ctx) {\n            const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath() // always start the path so we don't fill prior paths\n            ;\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'rect';\n    }\n}\n\nclass CircleElement extends PathElement {\n    path(ctx) {\n        const cx = this.getAttribute('cx').getPixels('x');\n        const cy = this.getAttribute('cy').getPixels('y');\n        const r = this.getAttribute('r').getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'circle';\n    }\n}\n\nclass EllipseElement extends PathElement {\n    path(ctx) {\n        const KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        const rx = this.getAttribute('rx').getPixels('x');\n        const ry = this.getAttribute('ry').getPixels('y');\n        const cx = this.getAttribute('cx').getPixels('x');\n        const cy = this.getAttribute('cy').getPixels('y');\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'ellipse';\n    }\n}\n\nclass LineElement extends PathElement {\n    getPoints() {\n        return [\n            new Point(this.getAttribute('x1').getPixels('x'), this.getAttribute('y1').getPixels('y')),\n            new Point(this.getAttribute('x2').getPixels('x'), this.getAttribute('y2').getPixels('y'))\n        ];\n    }\n    path(ctx) {\n        const [{ x: x0 , y: y0  }, { x: x1 , y: y1  }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        const [p0, p1] = this.getPoints();\n        const a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'line';\n    }\n}\n\nclass PolylineElement extends PathElement {\n    path(ctx) {\n        const { points  } = this;\n        const [{ x: x0 , y: y0  }] = points;\n        const boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((param)=>{\n            let { x , y  } = param;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        const { points  } = this;\n        const lastIndex = points.length - 1;\n        const markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'polyline';\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute('points').getString());\n    }\n}\n\nclass PolygonElement extends PolylineElement {\n    path(ctx) {\n        const boundingBox = super.path(ctx);\n        const [{ x , y  }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'polygon';\n    }\n}\n\nclass PatternElement extends Element {\n    createPattern(ctx, _, parentOpacityProp) {\n        const width = this.getStyle('width').getPixels('x', true);\n        const height = this.getStyle('height').getPixels('y', true);\n        // render me using a temporary svg element\n        const patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());\n        patternSvg.attributes.width = new Property(this.document, 'width', \"\".concat(width, \"px\"));\n        patternSvg.attributes.height = new Property(this.document, 'height', \"\".concat(height, \"px\"));\n        patternSvg.attributes.transform = new Property(this.document, 'transform', this.getAttribute('patternTransform').getValue());\n        patternSvg.children = this.children;\n        const patternCanvas = this.document.createCanvas(width, height);\n        const patternCtx = patternCanvas.getContext('2d');\n        const xAttr = this.getAttribute('x');\n        const yAttr = this.getAttribute('y');\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels('x', true), yAttr.getPixels('y', true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles['fill-opacity'] = parentOpacityProp;\n        } else {\n            Reflect.deleteProperty(this.styles, 'fill-opacity');\n        }\n        // render 3x3 grid so when we transform there's no white space on edges\n        for(let x = -1; x <= 1; x++){\n            for(let y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.x = new Property(this.document, 'x', x * patternCanvas.width);\n                patternSvg.attributes.y = new Property(this.document, 'y', y * patternCanvas.height);\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        const pattern = ctx.createPattern(patternCanvas, 'repeat');\n        return pattern;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'pattern';\n    }\n}\n\nclass MarkerElement extends Element {\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        const { x , y  } = point;\n        const orient = this.getAttribute('orient').getString('auto');\n        const markerUnits = this.getAttribute('markerUnits').getString('strokeWidth');\n        ctx.translate(x, y);\n        if (orient === 'auto') {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === 'strokeWidth') {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save();\n        // render me using a temporary svg element\n        const markerSvg = new SVGElement(this.document);\n        markerSvg.type = this.type;\n        markerSvg.attributes.viewBox = new Property(this.document, 'viewBox', this.getAttribute('viewBox').getValue());\n        markerSvg.attributes.refX = new Property(this.document, 'refX', this.getAttribute('refX').getValue());\n        markerSvg.attributes.refY = new Property(this.document, 'refY', this.getAttribute('refY').getValue());\n        markerSvg.attributes.width = new Property(this.document, 'width', this.getAttribute('markerWidth').getValue());\n        markerSvg.attributes.height = new Property(this.document, 'height', this.getAttribute('markerHeight').getValue());\n        markerSvg.attributes.overflow = new Property(this.document, 'overflow', this.getAttribute('overflow').getValue());\n        markerSvg.attributes.fill = new Property(this.document, 'fill', this.getAttribute('fill').getColor('black'));\n        markerSvg.attributes.stroke = new Property(this.document, 'stroke', this.getAttribute('stroke').getValue('none'));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === 'strokeWidth') {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === 'auto') {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'marker';\n    }\n}\n\nclass DefsElement extends Element {\n    render() {\n    // NOOP\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'defs';\n    }\n}\n\nclass GElement extends RenderedElement {\n    getBoundingBox(ctx) {\n        const boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'g';\n    }\n}\n\nclass GradientElement extends Element {\n    getGradientUnits() {\n        return this.getAttribute('gradientUnits').getString('objectBoundingBox');\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        let stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        const { stops  } = stopsContainer;\n        const gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute('gradientTransform').hasValue()) {\n            // render as transformed pattern on temporary canvas\n            const { document  } = this;\n            const { MAX_VIRTUAL_PIXELS  } = Screen;\n            const { viewPort  } = document.screen;\n            const rootView = viewPort.getRoot();\n            const rect = new RectElement(document);\n            rect.attributes.x = new Property(document, 'x', -MAX_VIRTUAL_PIXELS / 3);\n            rect.attributes.y = new Property(document, 'y', -MAX_VIRTUAL_PIXELS / 3);\n            rect.attributes.width = new Property(document, 'width', MAX_VIRTUAL_PIXELS);\n            rect.attributes.height = new Property(document, 'height', MAX_VIRTUAL_PIXELS);\n            const group = new GElement(document);\n            group.attributes.transform = new Property(document, 'transform', this.getAttribute('gradientTransform').getValue());\n            group.children = [\n                rect\n            ];\n            const patternSvg = new SVGElement(document);\n            patternSvg.attributes.x = new Property(document, 'x', 0);\n            patternSvg.attributes.y = new Property(document, 'y', 0);\n            patternSvg.attributes.width = new Property(document, 'width', rootView.width);\n            patternSvg.attributes.height = new Property(document, 'height', rootView.height);\n            patternSvg.children = [\n                group\n            ];\n            const patternCanvas = document.createCanvas(rootView.width, rootView.height);\n            const patternCtx = patternCanvas.getContext('2d');\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, 'no-repeat');\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            const colorProp = new Property(this.document, 'color', color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.attributesToInherit = [\n            'gradientUnits'\n        ];\n        this.stops = [];\n        const { stops , children  } = this;\n        children.forEach((child)=>{\n            if (child.type === 'stop') {\n                stops.push(child);\n            }\n        });\n    }\n}\n\nclass LinearGradientElement extends GradientElement {\n    getGradient(ctx, element) {\n        const isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';\n        const boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute('x1').hasValue() && !this.getAttribute('y1').hasValue() && !this.getAttribute('x2').hasValue() && !this.getAttribute('y2').hasValue()) {\n            this.getAttribute('x1', true).setValue(0);\n            this.getAttribute('y1', true).setValue(0);\n            this.getAttribute('x2', true).setValue(1);\n            this.getAttribute('y2', true).setValue(0);\n        }\n        const x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x1').getNumber() : this.getAttribute('x1').getPixels('x');\n        const y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y1').getNumber() : this.getAttribute('y1').getPixels('y');\n        const x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('x2').getNumber() : this.getAttribute('x2').getPixels('x');\n        const y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('y2').getNumber() : this.getAttribute('y2').getPixels('y');\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'linearGradient';\n        this.attributesToInherit.push('x1', 'y1', 'x2', 'y2');\n    }\n}\n\nclass RadialGradientElement extends GradientElement {\n    getGradient(ctx, element) {\n        const isBoundingBoxUnits = this.getGradientUnits() === 'objectBoundingBox';\n        const boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute('cx').hasValue()) {\n            this.getAttribute('cx', true).setValue('50%');\n        }\n        if (!this.getAttribute('cy').hasValue()) {\n            this.getAttribute('cy', true).setValue('50%');\n        }\n        if (!this.getAttribute('r').hasValue()) {\n            this.getAttribute('r', true).setValue('50%');\n        }\n        const cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('cx').getNumber() : this.getAttribute('cx').getPixels('x');\n        const cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('cy').getNumber() : this.getAttribute('cy').getPixels('y');\n        let fx = cx;\n        let fy = cy;\n        if (this.getAttribute('fx').hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute('fx').getNumber() : this.getAttribute('fx').getPixels('x');\n        }\n        if (this.getAttribute('fy').hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute('fy').getNumber() : this.getAttribute('fy').getPixels('y');\n        }\n        const r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute('r').getNumber() : this.getAttribute('r').getPixels();\n        const fr = this.getAttribute('fr').getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'radialGradient';\n        this.attributesToInherit.push('cx', 'cy', 'r', 'fx', 'fy', 'fr');\n    }\n}\n\nclass StopElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'stop';\n        const offset = Math.max(0, Math.min(1, this.getAttribute('offset').getNumber()));\n        const stopOpacity = this.getStyle('stop-opacity');\n        let stopColor = this.getStyle('stop-color', true);\n        if (stopColor.getString() === '') {\n            stopColor.setValue('#000');\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\n\nclass AnimateElement extends Element {\n    getProperty() {\n        const attributeType = this.getAttribute('attributeType').getString();\n        const attributeName = this.getAttribute('attributeName').getString();\n        if (attributeType === 'CSS') {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        const { initialUnits  } = this;\n        const { progress , from , to  } = this.getProgress();\n        // tween value linearly\n        let newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === '%') {\n            newValue *= 100 // numValue() returns 0-1 whereas properties are 0-100\n            ;\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        const { parent  } = this;\n        const prop = this.getProperty();\n        // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        }\n        // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            const fill = this.getAttribute('fill').getString('remove');\n            // loop for indefinitely repeating animations\n            if (this.getAttribute('repeatCount').getString() === 'indefinite' || this.getAttribute('repeatDur').getString() === 'indefinite') {\n                this.duration = 0;\n            } else if (fill === 'freeze' && !this.frozen) {\n                this.frozen = true;\n                if (parent && prop) {\n                    parent.animationFrozen = true;\n                    parent.animationFrozenValue = prop.getString();\n                }\n            } else if (fill === 'remove' && !this.removed) {\n                this.removed = true;\n                if (parent && prop) {\n                    prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                }\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta;\n        // if we're past the begin time\n        let updated = false;\n        if (this.begin < this.duration) {\n            let newValue = this.calcValue() // tween\n            ;\n            const typeAttr = this.getAttribute('type');\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                const type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        const { document , values  } = this;\n        let progress = (this.duration - this.begin) / (this.maxDuration - this.begin);\n        let from;\n        let to;\n        if (values.hasValue()) {\n            const p = progress * (values.getValue().length - 1);\n            const lb = Math.floor(p);\n            const ub = Math.ceil(p);\n            let value;\n            value = values.getValue()[lb];\n            from = new Property(document, 'from', value ? parseFloat(value) : 0);\n            value = values.getValue()[ub];\n            to = new Property(document, 'to', value ? parseFloat(value) : 0);\n            progress = (p - lb) / (ub - lb);\n        } else {\n            from = this.from;\n            to = this.to;\n        }\n        return {\n            progress,\n            from,\n            to\n        };\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'animate';\n        this.duration = 0;\n        this.initialUnits = '';\n        this.removed = false;\n        this.frozen = false;\n        document.screen.animations.push(this);\n        this.begin = this.getAttribute('begin').getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute('dur').getMilliseconds();\n        this.from = this.getAttribute('from');\n        this.to = this.getAttribute('to');\n        this.values = new Property(document, 'values', null);\n        const valuesAttr = this.getAttribute('values');\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(';'));\n        }\n    }\n}\n\nclass AnimateColorElement extends AnimateElement {\n    calcValue() {\n        const { progress , from , to  } = this.getProgress();\n        const colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(from.getColor());\n        const colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_1__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            const r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            const g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            const b = colorFrom.b + (colorTo.b - colorFrom.b) * progress;\n            // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute('from').getColor();\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'animateColor';\n    }\n}\n\nclass AnimateTransformElement extends AnimateElement {\n    calcValue() {\n        const { progress , from: from1 , to: to1  } = this.getProgress();\n        // tween value linearly\n        const transformFrom = toNumbers(from1.getString());\n        const transformTo = toNumbers(to1.getString());\n        const newValue = transformFrom.map((from, i)=>{\n            const to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(' ');\n        return newValue;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'animateTransform';\n    }\n}\n\nclass FontFaceElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'font-face';\n        this.ascent = this.getAttribute('ascent').getNumber();\n        this.descent = this.getAttribute('descent').getNumber();\n        this.unitsPerEm = this.getAttribute('units-per-em').getNumber();\n    }\n}\n\nclass GlyphElement extends PathElement {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'glyph';\n        this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();\n        this.unicode = this.getAttribute('unicode').getString();\n        this.arabicForm = this.getAttribute('arabic-form').getString();\n    }\n}\n\nclass MissingGlyphElement extends GlyphElement {\n    constructor(...args){\n        super(...args);\n        this.type = 'missing-glyph';\n        this.horizAdvX = 0;\n    }\n}\n\nclass FontElement extends Element {\n    render() {\n    // NO RENDER\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'font';\n        this.isArabic = false;\n        this.glyphs = {};\n        this.arabicGlyphs = {};\n        this.isRTL = false;\n        this.horizAdvX = this.getAttribute('horiz-adv-x').getNumber();\n        const { definitions  } = document;\n        const { children  } = this;\n        for (const child of children){\n            if (child instanceof FontFaceElement) {\n                this.fontFace = child;\n                const fontFamilyStyle = child.getStyle('font-family');\n                if (fontFamilyStyle.hasValue()) {\n                    definitions[fontFamilyStyle.getString()] = this;\n                }\n            } else if (child instanceof MissingGlyphElement) {\n                this.missingGlyph = child;\n            } else if (child instanceof GlyphElement) {\n                if (child.arabicForm) {\n                    this.isRTL = true;\n                    this.isArabic = true;\n                    const arabicGlyph = this.arabicGlyphs[child.unicode];\n                    if (typeof arabicGlyph === 'undefined') {\n                        this.arabicGlyphs[child.unicode] = {\n                            [child.arabicForm]: child\n                        };\n                    } else {\n                        arabicGlyph[child.arabicForm] = child;\n                    }\n                } else {\n                    this.glyphs[child.unicode] = child;\n                }\n            }\n        }\n    }\n}\n\nclass TRefElement extends TextElement {\n    getText() {\n        const element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            const firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return '';\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'tref';\n    }\n}\n\nclass AElement extends TextElement {\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            const { document , x , y  } = this;\n            const { mouse  } = document.screen;\n            const fontSize = new Property(document, 'fontSize', Font.parse(document.ctx.font).fontSize);\n            // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels('y'), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            const g = new GElement(this.document);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        const { window  } = this.document;\n        if (window) {\n            window.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        const ctx = this.document.ctx;\n        ctx.canvas.style.cursor = 'pointer';\n    }\n    constructor(document, node1, captureTextNodes){\n        super(document, node1, captureTextNodes);\n        this.type = 'a';\n        const { childNodes  } = node1;\n        const firstChild = childNodes[0];\n        const hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3\n        );\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : '';\n    }\n}\n\nclass TextPathElement extends TextElement {\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        const { dataArray  } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((param)=>{\n            let { type , points  } = param;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        const [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        const r = rx > ry ? rx : ry;\n                        const scaleX = rx > ry ? 1 : rx / ry;\n                        const scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        const textDecoration = this.parent.getStyle('text-decoration').getString();\n        const fontSize = this.getFontSize();\n        const { glyphInfo  } = this;\n        const fill = ctx.fillStyle;\n        if (textDecoration === 'underline') {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            const { p0 , p1 , rotation , text: partialText  } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === 'underline') {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            }\n        // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        //   ctx.strokeStyle = 'red';\n        // else\n        //   ctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === 'underline') {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        let idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        let offset = inputOffset;\n        let glyphWidth = this.measureText(ctx, c);\n        if (c === ' ' && anchor === 'justify' && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        const splineStep = this.textHeight / 20;\n        const p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        const p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        const segment = {\n            p0,\n            p1\n        };\n        const rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            const dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            const dyY = Math.cos(-rotation) * dy;\n            segment.p0 = {\n                ...p0,\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            };\n            segment.p1 = {\n                ...p1,\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            };\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        const { measuresCache  } = this;\n        const targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        const measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // This method supposes what all custom fonts already loaded.\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        const renderText = this.getText();\n        const chars = renderText.split('');\n        const spacesNumber = renderText.split(' ').length - 1;\n        const dx = this.parent.getAttribute('dx').split().map((_)=>_.getPixels('x')\n        );\n        const dy = this.parent.getAttribute('dy').getPixels('y');\n        const anchor = this.parent.getStyle('text-anchor').getString('start');\n        const thisSpacing = this.getStyle('letter-spacing');\n        const parentSpacing = this.parent.getStyle('letter-spacing');\n        let letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === 'inherit') {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== 'initial' && thisSpacing.getValue() !== 'unset') {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        }\n        // fill letter-spacing cache\n        const letterSpacingCache = [];\n        const textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(let i1 = 0; i1 < textLen; i1++){\n            letterSpacingCache.push(typeof dx[i1] !== 'undefined' ? dx[i1] : letterSpacing);\n        }\n        const dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0\n        , 0);\n        const textWidth = this.measureText(ctx);\n        const textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        const fullPathWidth = this.getPathLength();\n        const startOffset = this.getStyle('startOffset').getNumber(0) * fullPathWidth;\n        let offset = 0;\n        if (anchor === 'middle' || anchor === 'center') {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === 'end' || anchor === 'right') {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            const { offset: nextOffset , segment , rotation  } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            }\n            // const width = this.getLineLength(\n            //   segment.p0.x,\n            //   segment.p0.y,\n            //   segment.p1.x,\n            //   segment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            //   kern + width / 2.0,\n            //   segment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1 // reset path length\n        ;\n        if (!path) {\n            return [];\n        }\n        const pathCommands = [];\n        const { pathParser  } = path;\n        pathParser.reset();\n        // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            const { current  } = pathParser;\n            const startX = current ? current.x : 0;\n            const startY = current ? current.y : 0;\n            const command = pathParser.next();\n            let nextCommandType = command.type;\n            let points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        const { x , y  } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        const { x , y  } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        const { x , y  } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        const { x , y  } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        const { point , controlPoint , currentPoint  } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        const { point , controlPoint , currentPoint  } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        const { controlPoint , currentPoint  } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        const { controlPoint , currentPoint  } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        let { rX , rY , sweepFlag , xAxisRotation , centp , a1 , ad  } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        let len = 0;\n        let p1 = null;\n        let p2 = null;\n        let t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0;\n                    const start = points[4];\n                    // 4 = theta\n                    const dTheta = points[5];\n                    // 5 = dTheta\n                    const end = points[4] + dTheta;\n                    let inc = Math.PI / 180;\n                    // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    }\n                    // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        let fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x, fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;\n        const m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        let run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        let rise = m * run;\n        let pt = null;\n        if (p2x === p1x) {\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            let ix = 0;\n            let iy = 0;\n            const len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            let u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            const pRise = this.getLineLength(fromX, fromY, ix, iy);\n            const pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        const fullLen = this.getPathLength();\n        let cumulativePathLength = 0;\n        let p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        const { dataArray  } = this;\n        for (const command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            const delta = distance - cumulativePathLength;\n            let currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        const start = command.points[4];\n                        // 4 = theta\n                        const dTheta = command.points[5];\n                        // 5 = dTheta\n                        const end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length\n            , 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        const x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        const y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        const x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        const y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        const cosPsi = Math.cos(psi);\n        const sinPsi = Math.sin(psi);\n        const pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    // TODO need some optimisations. possibly build cache only for curved segments?\n    buildEquidistantCache(inputStep, inputPrecision) {\n        const fullLen = this.getPathLength();\n        const precision = inputPrecision || 0.25 // accuracy vs performance\n        ;\n        const step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            };\n            // Calculate points\n            let s = 0;\n            for(let l = 0; l <= fullLen; l += precision){\n                const p0 = this.getPointOnPath(l);\n                const p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        const idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'textPath';\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                '',\n                0\n            ]\n        ]);\n        const pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n}\n\n// groups: 1: mime-type (+ charset), 2: mime-type (w/o charset), 3: charset, 4: base64?, 5: body\nconst dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    async loadImage(href) {\n        try {\n            const image = await this.document.createImage(href);\n            this.image = image;\n        } catch (err) {\n            console.error(\"Error while loading image \\\"\".concat(href, \"\\\":\"), err);\n        }\n        this.loaded = true;\n    }\n    async loadSvg(href) {\n        const match = dataUriRegex.exec(href);\n        if (match) {\n            const data = match[5];\n            if (data) {\n                if (match[4] === 'base64') {\n                    this.image = atob(data);\n                } else {\n                    this.image = decodeURIComponent(data);\n                }\n            }\n        } else {\n            try {\n                const response = await this.document.fetch(href);\n                const svg = await response.text();\n                this.image = svg;\n            } catch (err) {\n                console.error(\"Error while loading image \\\"\".concat(href, \"\\\":\"), err);\n            }\n        }\n        this.loaded = true;\n    }\n    renderChildren(ctx) {\n        const { document , image , loaded  } = this;\n        const x = this.getAttribute('x').getPixels('x');\n        const y = this.getAttribute('y').getPixels('y');\n        const width = this.getStyle('width').getPixels('x');\n        const height = this.getStyle('height').getPixels('y');\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (typeof image === 'string') {\n            const subDocument = document.canvg.forkString(ctx, image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            const { documentElement  } = subDocument.document;\n            if (documentElement) {\n                documentElement.parent = this;\n            }\n            void subDocument.render();\n        } else {\n            document.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute('preserveAspectRatio').getString(),\n                width,\n                desiredWidth: image.width,\n                height,\n                desiredHeight: image.height\n            });\n            if (this.loaded) {\n                if (!('complete' in image) || image.complete) {\n                    ctx.drawImage(image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        const x = this.getAttribute('x').getPixels('x');\n        const y = this.getAttribute('y').getPixels('y');\n        const width = this.getStyle('width').getPixels('x');\n        const height = this.getStyle('height').getPixels('y');\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'image';\n        this.loaded = false;\n        const href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        const isSvg = href.endsWith('.svg') || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n    }\n}\n\nclass SymbolElement extends RenderedElement {\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'symbol';\n    }\n}\n\nclass SVGFontLoader {\n    async load(fontFamily, url) {\n        try {\n            const { document  } = this;\n            const svgDocument = await document.canvg.parser.load(url);\n            const fonts = svgDocument.getElementsByTagName('font');\n            Array.from(fonts).forEach((fontNode)=>{\n                const font = document.createElement(fontNode);\n                document.definitions[fontFamily] = font;\n            });\n        } catch (err) {\n            console.error(\"Error while loading font \\\"\".concat(url, \"\\\":\"), err);\n        }\n        this.loaded = true;\n    }\n    constructor(document){\n        this.document = document;\n        this.loaded = false;\n        document.fonts.push(this);\n    }\n}\n\nclass StyleElement extends Element {\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'style';\n        const css = compressSpaces(Array.from(node.childNodes)// NEED TEST\n        .map((_)=>_.textContent\n        ).join('').replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, '') // remove comments\n        .replace(/@import.*;/g, '') // remove imports\n        );\n        const cssDefs = css.split('}');\n        cssDefs.forEach((_1)=>{\n            const def = _1.trim();\n            if (!def) {\n                return;\n            }\n            const cssParts = def.split('{');\n            const cssClasses = cssParts[0].split(',');\n            const cssProps = cssParts[1].split(';');\n            cssClasses.forEach((_)=>{\n                const cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                const props = document.styles[cssClass] || {};\n                cssProps.forEach((cssProp)=>{\n                    const prop = cssProp.indexOf(':');\n                    const name = cssProp.substr(0, prop).trim();\n                    const value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document, name, value);\n                    }\n                });\n                document.styles[cssClass] = props;\n                document.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === '@font-face') {\n                    const fontFamily = props['font-family'].getString().replace(/\"|'/g, '');\n                    const srcs = props.src.getString().split(',');\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            const url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\n\nclass UseElement extends RenderedElement {\n    setContext(ctx) {\n        super.setContext(ctx);\n        const xAttr = this.getAttribute('x');\n        const yAttr = this.getAttribute('y');\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels('x'), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels('y'));\n        }\n    }\n    path(ctx) {\n        const { element  } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        const { document , element  } = this;\n        if (element) {\n            let tempSvg = element;\n            if (element.type === 'symbol') {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document);\n                tempSvg.attributes.viewBox = new Property(document, 'viewBox', element.getAttribute('viewBox').getString());\n                tempSvg.attributes.preserveAspectRatio = new Property(document, 'preserveAspectRatio', element.getAttribute('preserveAspectRatio').getString());\n                tempSvg.attributes.overflow = new Property(document, 'overflow', element.getAttribute('overflow').getString());\n                tempSvg.children = element.children;\n                // element is still the parent of the children\n                element.styles.opacity = new Property(document, 'opacity', this.calculateOpacity());\n            }\n            if (tempSvg.type === 'svg') {\n                const widthStyle = this.getStyle('width', false, true);\n                const heightStyle = this.getStyle('height', false, true);\n                // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.width = new Property(document, 'width', widthStyle.getString());\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.height = new Property(document, 'height', heightStyle.getString());\n                }\n            }\n            const oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        const { element  } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        const { document , element  } = this;\n        if (!element) {\n            return null;\n        }\n        return Transform.fromElement(document, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'use';\n    }\n}\n\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    const mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        const { includeOpacity , matrix  } = this;\n        const srcData = ctx.getImageData(0, 0, width, height);\n        for(let y = 0; y < height; y++){\n            for(let x = 0; x < width; x++){\n                const r = imGet(srcData.data, x, y, width, height, 0);\n                const g = imGet(srcData.data, x, y, width, height, 1);\n                const b = imGet(srcData.data, x, y, width, height, 2);\n                const a = imGet(srcData.data, x, y, width, height, 3);\n                let nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                let ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                let nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                let na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'feColorMatrix';\n        let matrix = toNumbers(this.getAttribute('values').getString());\n        switch(this.getAttribute('type').getString('matrix')){\n            case 'saturate':\n                {\n                    const s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case 'hueRotate':\n                {\n                    const a = matrix[0] * Math.PI / 180;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.14),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case 'luminanceToAlpha':\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute('includeOpacity').hasValue();\n    }\n}\n\nclass MaskElement extends Element {\n    apply(ctx, element) {\n        const { document  } = this;\n        // render as temp svg\n        let x = this.getAttribute('x').getPixels('x');\n        let y = this.getAttribute('y').getPixels('y');\n        let width = this.getStyle('width').getPixels('x');\n        let height = this.getStyle('height').getPixels('y');\n        if (!width && !height) {\n            const boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        const ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        const maskCanvas = document.createCanvas(x + width, y + height);\n        const maskCtx = maskCanvas.getContext('2d');\n        document.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx);\n        // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: 'type',\n                    value: 'luminanceToAlpha'\n                },\n                {\n                    nodeName: 'includeOpacity',\n                    value: 'true'\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        const tmpCanvas = document.createCanvas(x + width, y + height);\n        const tmpCtx = tmpCanvas.getContext('2d');\n        document.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = 'destination-in';\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, 'no-repeat');\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, 'no-repeat');\n        ctx.fillRect(0, 0, x + width, y + height);\n        // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'mask';\n    }\n}\nMaskElement.ignoreStyles = [\n    'mask',\n    'transform',\n    'clip-path'\n];\n\nconst noop = ()=>{\n// NOOP\n};\nclass ClipPathElement extends Element {\n    apply(ctx) {\n        const { document  } = this;\n        const contextProto = Reflect.getPrototypeOf(ctx);\n        const { beginPath , closePath  } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (!('path' in child)) {\n                return;\n            }\n            let transform = 'elementTransform' in child ? child.elementTransform() : null // handle <use />\n            ;\n            if (!transform) {\n                transform = Transform.fromElement(document, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'clipPath';\n    }\n}\n\nclass FilterElement extends Element {\n    apply(ctx, element) {\n        // render as temp svg\n        const { document , children  } = this;\n        const boundingBox = 'getBoundingBox' in element ? element.getBoundingBox(ctx) : null;\n        if (!boundingBox) {\n            return;\n        }\n        let px = 0;\n        let py = 0;\n        children.forEach((child)=>{\n            const efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        const width = Math.floor(boundingBox.width);\n        const height = Math.floor(boundingBox.height);\n        const tmpCanvasWidth = width + 2 * px;\n        const tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        const x = Math.floor(boundingBox.x);\n        const y = Math.floor(boundingBox.y);\n        const ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        const tmpCanvas = document.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        const tmpCtx = tmpCanvas.getContext('2d');\n        document.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx);\n        // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === 'function') {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        });\n        // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {\n    // NO RENDER\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'filter';\n    }\n}\nFilterElement.ignoreStyles = [\n    'filter',\n    'transform',\n    'clip-path'\n];\n\nclass FeDropShadowElement extends Element {\n    apply(_, _x, _y, _width, _height) {\n    // TODO: implement\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'feDropShadow';\n        this.addStylesFromStyleDefinition();\n    }\n}\n\nclass FeMorphologyElement extends Element {\n    apply(_, _x, _y, _width, _height) {\n    // TODO: implement\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'feMorphology';\n    }\n}\n\nclass FeCompositeElement extends Element {\n    apply(_, _x, _y, _width, _height) {\n    // TODO: implement\n    }\n    constructor(...args){\n        super(...args);\n        this.type = 'feComposite';\n    }\n}\n\nclass FeGaussianBlurElement extends Element {\n    apply(ctx, x, y, width, height) {\n        const { document , blurRadius  } = this;\n        const body = document.window ? document.window.document.body : null;\n        const canvas = ctx.canvas;\n        // StackBlur requires canvas be on document\n        canvas.id = document.getUniqueId();\n        if (body) {\n            canvas.style.display = 'none';\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_3__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n    constructor(document, node, captureTextNodes){\n        super(document, node, captureTextNodes);\n        this.type = 'feGaussianBlur';\n        this.blurRadius = Math.floor(this.getAttribute('stdDeviation').getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n}\n\nclass TitleElement extends Element {\n    constructor(...args){\n        super(...args);\n        this.type = 'title';\n    }\n}\n\nclass DescElement extends Element {\n    constructor(...args){\n        super(...args);\n        this.type = 'desc';\n    }\n}\n\nconst elements = {\n    'svg': SVGElement,\n    'rect': RectElement,\n    'circle': CircleElement,\n    'ellipse': EllipseElement,\n    'line': LineElement,\n    'polyline': PolylineElement,\n    'polygon': PolygonElement,\n    'path': PathElement,\n    'pattern': PatternElement,\n    'marker': MarkerElement,\n    'defs': DefsElement,\n    'linearGradient': LinearGradientElement,\n    'radialGradient': RadialGradientElement,\n    'stop': StopElement,\n    'animate': AnimateElement,\n    'animateColor': AnimateColorElement,\n    'animateTransform': AnimateTransformElement,\n    'font': FontElement,\n    'font-face': FontFaceElement,\n    'missing-glyph': MissingGlyphElement,\n    'glyph': GlyphElement,\n    'text': TextElement,\n    'tspan': TSpanElement,\n    'tref': TRefElement,\n    'a': AElement,\n    'textPath': TextPathElement,\n    'image': ImageElement,\n    'g': GElement,\n    'symbol': SymbolElement,\n    'style': StyleElement,\n    'use': UseElement,\n    'mask': MaskElement,\n    'clipPath': ClipPathElement,\n    'filter': FilterElement,\n    'feDropShadow': FeDropShadowElement,\n    'feMorphology': FeMorphologyElement,\n    'feComposite': FeCompositeElement,\n    'feColorMatrix': FeColorMatrixElement,\n    'feGaussianBlur': FeGaussianBlurElement,\n    'title': TitleElement,\n    'desc': DescElement\n};\n\nfunction createCanvas(width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nasync function createImage(src) {\n    let anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const image = document.createElement('img');\n    if (anonymousCrossOrigin) {\n        image.crossOrigin = 'Anonymous';\n    }\n    return new Promise((resolve, reject)=>{\n        image.onload = ()=>{\n            resolve(image);\n        };\n        image.onerror = (_event, _source, _lineno, _colno, error)=>{\n            reject(error);\n        };\n        image.src = src;\n    });\n}\nconst DEFAULT_EM_SIZE = 12;\nclass Document {\n    bindCreateImage(createImage1, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === 'boolean') {\n            return (source, forceAnonymousCrossOrigin)=>createImage1(source, typeof forceAnonymousCrossOrigin === 'boolean' ? forceAnonymousCrossOrigin : anonymousCrossOrigin)\n            ;\n        }\n        return createImage1;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        const { emSizeStack  } = this;\n        return emSizeStack[emSizeStack.length - 1] || DEFAULT_EM_SIZE;\n    }\n    set emSize(value) {\n        const { emSizeStack  } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        const { emSizeStack  } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded\n        );\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded\n        );\n    }\n    createDocumentElement(document) {\n        const documentElement = this.createElement(document.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        const elementType = node.nodeName.replace(/^[^:]+:/, '');\n        const ElementType = Document.elementTypes[elementType];\n        if (ElementType) {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox({\n            document: this,\n            ...config\n        });\n    }\n    constructor(canvg, { rootEmSize =DEFAULT_EM_SIZE , emSize =DEFAULT_EM_SIZE , createCanvas: createCanvas1 = Document.createCanvas , createImage: createImage2 = Document.createImage , anonymousCrossOrigin  } = {}){\n        this.canvg = canvg;\n        this.definitions = {};\n        this.styles = {};\n        this.stylesSpecificity = {};\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas1;\n        this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);\n        this.screen.wait(()=>this.isImagesLoaded()\n        );\n        this.screen.wait(()=>this.isFontsLoaded()\n        );\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\n\n/**\n * SVG renderer on canvas.\n */ class Canvg {\n    /**\n   * Create Canvg instance from SVG source string or URL.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string or URL.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ static async from(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const parser = new Parser(options);\n        const svgDocument = await parser.parse(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\n   * Create Canvg instance from SVG source string.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ static fromString(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const parser = new Parser(options);\n        const svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\n   * Create new Canvg instance with inherited options.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string or URL.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ fork(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return Canvg.from(ctx, svg, {\n            ...this.options,\n            ...options\n        });\n    }\n    /**\n   * Create new Canvg instance with inherited options.\n   * @param ctx - Rendering context.\n   * @param svg - SVG source string.\n   * @param options - Rendering options.\n   * @returns Canvg instance.\n   */ forkString(ctx, svg) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, {\n            ...this.options,\n            ...options\n        });\n    }\n    /**\n   * Document is ready promise.\n   * @returns Ready promise.\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\n   * Document is ready value.\n   * @returns Is ready or not.\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\n   * Render only first frame, ignoring animations and mouse.\n   * @param options - Rendering options.\n   */ async render() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this.start({\n            enableRedraw: true,\n            ignoreAnimation: true,\n            ignoreMouse: true,\n            ...options\n        });\n        await this.ready();\n        this.stop();\n    }\n    /**\n   * Start rendering.\n   * @param options - Render options.\n   */ start() {\n        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        const { documentElement , screen , options: baseOptions  } = this;\n        screen.start(documentElement, {\n            enableRedraw: true,\n            ...baseOptions,\n            ...options\n        });\n    }\n    /**\n   * Stop rendering.\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\n   * Resize SVG to fit in given size.\n   * @param width\n   * @param height\n   * @param preserveAspectRatio\n   */ resize(width) {\n        let height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width, preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n    /**\n   * Main constructor.\n   * @param ctx - Rendering context.\n   * @param svg - SVG Document.\n   * @param options - Rendering options.\n   */ constructor(ctx, svg, options = {}){\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        const document = new Document(this, options);\n        const documentElement = document.createDocumentElement(svg);\n        this.document = document;\n        this.documentElement = documentElement;\n    }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ1I7QUFDVztBQUNHOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUNBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdELGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzSkFBc0o7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpTEFBaUw7QUFDL0wsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQ0FBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpREFBaUQsSUFBSTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQXFELElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTLFNBQVMsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsU0FBUyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EseUNBQXlDLDJCQUEyQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHFEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFEQUFXLGlDQUFpQyxxREFBVyx3Q0FBd0MscURBQVcsZ0NBQWdDLHFEQUFXO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXLGlCQUFpQixhQUFhLG9CQUFvQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixTQUFTO0FBQ3pCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsbUJBQW1CO0FBQ25DLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLG1CQUFtQjtBQUNuQyxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCLGdCQUFnQixtQkFBbUI7QUFDbkMsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0Isd0VBQXdFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx5QkFBeUIseUxBQXlMLElBQUk7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFtRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaXBDO0FBQ2pwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2VfbmV4dGdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9jYW52Zy9kaXN0L2luZGV4LmpzPzhhNTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcm9tICdyYWYnO1xuaW1wb3J0IFJHQkNvbG9yIGZyb20gJ3JnYmNvbG9yJztcbmltcG9ydCB7IFNWR1BhdGhEYXRhIH0gZnJvbSAnc3ZnLXBhdGhkYXRhJztcbmltcG9ydCB7IGNhbnZhc1JHQkEgfSBmcm9tICdzdGFja2JsdXItY2FudmFzJztcblxuLyoqXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYE9mZnNjcmVlbkNhbnZhc2AuXG4gKiBAcGFyYW0gY29uZmlnIC0gUHJlc2V0IHJlcXVpcmVtZW50cy5cbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cbiAqLyBmdW5jdGlvbiBvZmZzY3JlZW4oKSB7XG4gICAgbGV0IHsgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFjayAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgcHJlc2V0ID0ge1xuICAgICAgICB3aW5kb3c6IG51bGwsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIERPTVBhcnNlcjogRE9NUGFyc2VyRmFsbGJhY2ssXG4gICAgICAgIGNyZWF0ZUNhbnZhcyAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNyZWF0ZUltYWdlICh1cmwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcbiAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5ET01QYXJzZXIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBET01QYXJzZXJGYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShwcmVzZXQsICdET01QYXJzZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXNldDtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYG5vZGUtY2FudmFzYC5cbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxuICogQHBhcmFtIGNvbmZpZy5ET01QYXJzZXIgLSBYTUwvSFRNTCBwYXJzZXIgZnJvbSBzdHJpbmcgaW50byBET00gRG9jdW1lbnQuXG4gKiBAcGFyYW0gY29uZmlnLmNhbnZhcyAtIGBub2RlLWNhbnZhc2AgZXhwb3J0cy5cbiAqIEBwYXJhbSBjb25maWcuZmV0Y2ggLSBXSEFUV0ctY29tcGF0aWJsZSBgZmV0Y2hgIGZ1bmN0aW9uLlxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cbiAqLyBmdW5jdGlvbiBub2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgRE9NUGFyc2VyICwgY2FudmFzICwgZmV0Y2ggIH0gPSBwYXJhbTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aW5kb3c6IG51bGwsXG4gICAgICAgIGlnbm9yZUFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgIERPTVBhcnNlcixcbiAgICAgICAgZmV0Y2gsXG4gICAgICAgIGNyZWF0ZUNhbnZhczogY2FudmFzLmNyZWF0ZUNhbnZhcyxcbiAgICAgICAgY3JlYXRlSW1hZ2U6IGNhbnZhcy5sb2FkSW1hZ2VcbiAgICB9O1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgb2Zmc2NyZWVuOiBvZmZzY3JlZW4sXG4gIG5vZGU6IG5vZGVcbn0pO1xuXG4vKipcbiAqIEhUTUwtc2FmZSBjb21wcmVzcyB3aGl0ZS1zcGFjZXMuXG4gKiBAcGFyYW0gc3RyIC0gU3RyaW5nIHRvIGNvbXByZXNzLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIGNvbXByZXNzU3BhY2VzKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKD8hXFx1MzAwMClcXHMrL2dtLCAnICcpO1xufVxuLyoqXG4gKiBIVE1MLXNhZmUgbGVmdCB0cmltLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXG4gXFx0XSsvLCAnJyk7XG59XG4vKipcbiAqIEhUTUwtc2FmZSByaWdodCB0cmltLlxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMgU3RyaW5nLlxuICovIGZ1bmN0aW9uIHRyaW1SaWdodChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXG4gXFx0XSskLywgJycpO1xufVxuLyoqXG4gKiBTdHJpbmcgdG8gbnVtYmVycyBhcnJheS5cbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cbiAqIEByZXR1cm5zIE51bWJlcnMgYXJyYXkuXG4gKi8gZnVuY3Rpb24gdG9OdW1iZXJzKHN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goLy0/KFxcZCsoPzpcXC5cXGQqKD86W2VFXVsrLV0/XFxkKyk/KT98XFwuXFxkKykoPz1cXER8JCkvZ20pO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlcy5tYXAocGFyc2VGbG9hdCkgOiBbXTtcbn1cbi8qKlxuICogU3RyaW5nIHRvIG1hdHJpeCB2YWx1ZS5cbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cbiAqIEByZXR1cm5zIE1hdHJpeCB2YWx1ZS5cbiAqLyBmdW5jdGlvbiB0b01hdHJpeFZhbHVlKHN0cikge1xuICAgIGNvbnN0IG51bWJlcnMgPSB0b051bWJlcnMoc3RyKTtcbiAgICBjb25zdCBtYXRyaXggPSBbXG4gICAgICAgIG51bWJlcnNbMF0gfHwgMCxcbiAgICAgICAgbnVtYmVyc1sxXSB8fCAwLFxuICAgICAgICBudW1iZXJzWzJdIHx8IDAsXG4gICAgICAgIG51bWJlcnNbM10gfHwgMCxcbiAgICAgICAgbnVtYmVyc1s0XSB8fCAwLFxuICAgICAgICBudW1iZXJzWzVdIHx8IDBcbiAgICBdO1xuICAgIHJldHVybiBtYXRyaXg7XG59XG4vLyBNaWNyb3NvZnQgRWRnZSBmaXhcbmNvbnN0IGFsbFVwcGVyY2FzZSA9IC9eW0EtWi1dKyQvO1xuLyoqXG4gKiBOb3JtYWxpemUgYXR0cmlidXRlIG5hbWUuXG4gKiBAcGFyYW0gbmFtZSAtIEF0dHJpYnV0ZSBuYW1lLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBhdHRyaWJ1dGUgbmFtZS5cbiAqLyBmdW5jdGlvbiBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgICBpZiAoYWxsVXBwZXJjYXNlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbiAqIFBhcnNlIGV4dGVybmFsIFVSTC5cbiAqIEBwYXJhbSB1cmwgLSBDU1MgdXJsIHN0cmluZy5cbiAqIEByZXR1cm5zIFBhcnNlZCBVUkwuXG4gKi8gZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFVybCh1cmwpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBzaW5nbGUgcXVvdGVzIFsyXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICBkb3VibGUgcXVvdGVzIFszXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgbm8gcXVvdGVzIFs0XVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgdlxuICAgIGNvbnN0IHVybE1hdGNoID0gL3VybFxcKCgnKFteJ10rKSd8XCIoW15cIl0rKVwifChbXidcIildKykpXFwpLy5leGVjKHVybCk7XG4gICAgaWYgKCF1cmxNYXRjaCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB1cmxNYXRjaFsyXSB8fCB1cmxNYXRjaFszXSB8fCB1cmxNYXRjaFs0XSB8fCAnJztcbn1cbi8qKlxuICogVHJhbnNmb3JtIGZsb2F0cyB0byBpbnRlZ2VycyBpbiByZ2IgY29sb3JzLlxuICogQHBhcmFtIGNvbG9yIC0gQ29sb3IgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgTm9ybWFsaXplZCBjb2xvci5cbiAqLyBmdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3Iuc3RhcnRzV2l0aCgncmdiJykpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBsZXQgcmdiUGFydHMgPSAzO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IGNvbG9yLnJlcGxhY2UoL1xcZCsoXFwuXFxkKyk/L2csIChudW0sIGlzRmxvYXQpPT4ocmdiUGFydHMtLSkgJiYgaXNGbG9hdCA/IFN0cmluZyhNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtKSkpIDogbnVtXG4gICAgKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZENvbG9yO1xufVxuXG4vLyBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWVnYW5zdHJlZXQvc3BlY2lmaWNpdHkvYmxvYi9tYXN0ZXIvc3BlY2lmaWNpdHkuanNcbmNvbnN0IGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xuY29uc3QgaWRSZWdleCA9IC8oI1teXFxzKz5+Lls6XSspL2c7XG5jb25zdCBjbGFzc1JlZ2V4ID0gLyhcXC5bXlxccys+fi5bOl0rKS9nO1xuY29uc3QgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzKz5+Lls6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XG5jb25zdCBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteKV0qXFwpKS9naTtcbmNvbnN0IHBzZXVkb0NsYXNzUmVnZXggPSAvKDpbXlxccys+fi5bOl0rKS9nO1xuY29uc3QgZWxlbWVudFJlZ2V4ID0gLyhbXlxccys+fi5bOl0rKS9nO1xuZnVuY3Rpb24gZmluZFNlbGVjdG9yTWF0Y2goc2VsZWN0b3IsIHJlZ2V4KSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHJlZ2V4LmV4ZWMoc2VsZWN0b3IpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdG9yLnJlcGxhY2UocmVnZXgsICcgJyksXG4gICAgICAgIG1hdGNoZXMubGVuZ3RoXG4gICAgXTtcbn1cbi8qKlxuICogTWVhc3VyZSBzZWxlY3RvciBzcGVjaWZpY2l0eS5cbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIG1lYXN1cmUuXG4gKiBAcmV0dXJucyBTcGVjaWZpY2l0eS5cbiAqLyBmdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XG4gICAgY29uc3Qgc3BlY2lmaWNpdHkgPSBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICBdO1xuICAgIGxldCBjdXJyZW50U2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC86bm90XFwoKFteKV0qKVxcKS9nLCAnICAgICAkMSAnKS5yZXBsYWNlKC97W1xcc1xcU10qL2dtLCAnICcpO1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBhdHRyaWJ1dGVSZWdleCk7XG4gICAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gICAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBpZFJlZ2V4KTtcbiAgICBzcGVjaWZpY2l0eVswXSArPSBkZWx0YTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGNsYXNzUmVnZXgpO1xuICAgIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICAgIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvRWxlbWVudFJlZ2V4KTtcbiAgICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXgpO1xuICAgIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICAgIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NSZWdleCk7XG4gICAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gICAgY3VycmVudFNlbGVjdG9yID0gY3VycmVudFNlbGVjdG9yLnJlcGxhY2UoL1sqXFxzKz5+XS9nLCAnICcpLnJlcGxhY2UoL1sjLl0vZywgJyAnKTtcbiAgICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGVsZW1lbnRSZWdleCkgLy8gbGd0bSBbanMvdXNlbGVzcy1hc3NpZ25tZW50LXRvLWxvY2FsXVxuICAgIDtcbiAgICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgICByZXR1cm4gc3BlY2lmaWNpdHkuam9pbignJyk7XG59XG5cbmNvbnN0IFBTRVVET19aRVJPID0gMC4wMDAwMDAwMTtcbi8qKlxuICogVmVjdG9yIG1hZ25pdHVkZS5cbiAqIEBwYXJhbSB2XG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxuICovIGZ1bmN0aW9uIHZlY3Rvck1hZ25pdHVkZSh2KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2WzBdLCAyKSArIE1hdGgucG93KHZbMV0sIDIpKTtcbn1cbi8qKlxuICogUmF0aW8gYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB1XG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cbiAqLyBmdW5jdGlvbiB2ZWN0b3JzUmF0aW8odSwgdikge1xuICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodmVjdG9yTWFnbml0dWRlKHUpICogdmVjdG9yTWFnbml0dWRlKHYpKTtcbn1cbi8qKlxuICogQW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSB1XG4gKiBAcGFyYW0gdlxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cbiAqLyBmdW5jdGlvbiB2ZWN0b3JzQW5nbGUodSwgdikge1xuICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModmVjdG9yc1JhdGlvKHUsIHYpKTtcbn1cbmZ1bmN0aW9uIENCMSh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIENCMih0KSB7XG4gICAgcmV0dXJuIDMgKiB0ICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjModCkge1xuICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0I0KHQpIHtcbiAgICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIxKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBRQjIodCkge1xuICAgIHJldHVybiAyICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjModCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbn1cblxuY2xhc3MgUHJvcGVydHkge1xuICAgIHN0YXRpYyBlbXB0eShkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnRU1QVFknLCAnJyk7XG4gICAgfVxuICAgIHNwbGl0KCkge1xuICAgICAgICBsZXQgc2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAnICc7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBuYW1lICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0U3RyaW5nKCkpLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpLm1hcCgodmFsdWUpPT5uZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKVxuICAgICAgICApO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh6ZXJvSXNWYWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHplcm9Jc1ZhbHVlIHx8IHZhbHVlICE9PSAwKSAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpc1N0cmluZyhyZWdleHApIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZWdleHApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKTtcbiAgICB9XG4gICAgaXNVcmxEZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N0cmluZygvXnVybFxcKC8pO1xuICAgIH1cbiAgICBpc1BpeGVscygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG4gICAgICAgIHN3aXRjaCh0cnVlKXtcbiAgICAgICAgICAgIGNhc2UgYXNTdHJpbmcuZW5kc1dpdGgoJ3B4Jyk6XG4gICAgICAgICAgICBjYXNlIC9eWzAtOV0rJC8udGVzdChhc1N0cmluZyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRWYWx1ZShkZWYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgZ2V0TnVtYmVyKGRlZikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhcnNlIHVua25vd24gdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChkZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmFsdWUgIH0gPSB0aGlzO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhcnNlIHVua25vd24gdmFsdWUuXG4gICAgICAgIGxldCBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC8lJC8pKSB7XG4gICAgICAgICAgICBuIC89IDEwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZ2V0U3RyaW5nKGRlZikge1xuICAgICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyhkZWYpO1xuICAgIH1cbiAgICBnZXRDb2xvcihkZWYpIHtcbiAgICAgICAgbGV0IGNvbG9yID0gdGhpcy5nZXRTdHJpbmcoZGVmKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOb3JtYWxpemVkQ29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gdHJ1ZTtcbiAgICAgICAgY29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgICAgIHRoaXMudmFsdWUgPSBjb2xvcjtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBnZXREcGkoKSB7XG4gICAgICAgIHJldHVybiA5NiAvLyBUT0RPOiBjb21wdXRlP1xuICAgICAgICA7XG4gICAgfVxuICAgIGdldFJlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICB9XG4gICAgZ2V0RW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmVtU2l6ZTtcbiAgICB9XG4gICAgZ2V0VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0cmluZygpLnJlcGxhY2UoL1swLTkuLV0vZywgJycpO1xuICAgIH1cbiAgICBnZXRQaXhlbHMoYXhpc09ySXNGb250U2l6ZSkge1xuICAgICAgICBsZXQgcHJvY2Vzc1BlcmNlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2F4aXMsIGlzRm9udFNpemVdID0gdHlwZW9mIGF4aXNPcklzRm9udFNpemUgPT09ICdib29sZWFuJyA/IFtcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGF4aXNPcklzRm9udFNpemVcbiAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIGF4aXNPcklzRm9udFNpemVcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgeyB2aWV3UG9ydCAgfSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuO1xuICAgICAgICBzd2l0Y2godHJ1ZSl7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtaW4kLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAgKiBNYXRoLm1pbih2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1heCQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMCAqIE1hdGgubWF4KHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92dyQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4Jyk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmVtJC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRSZW0oKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZW0kLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2V4JC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpIC8gMjtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHgkLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B0JC8pOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAqICgxIC8gNzIpO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9wYyQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDE1O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9jbSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyLjU0O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9tbSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyNS40O1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9pbiQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykgJiYgaXNGb250U2l6ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvJSQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKGF4aXMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB0aGlzLmdldE51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc1BlcmNlbnQgJiYgbiA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuICogdmlld1BvcnQuY29tcHV0ZVNpemUoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC9tcyQvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxMDAwO1xuICAgIH1cbiAgICBnZXRSYWRpYW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9kZWckLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2dyYWQkLyk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDIwMCk7XG4gICAgICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JhZCQvKTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgY29uc3QgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC8jKFteKSdcIl0rKS8uZXhlYyhhc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoWzFdKSB8fCBhc1N0cmluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmaW5pdGlvbnNbbmFtZV07XG4gICAgfVxuICAgIGdldEZpbGxTdHlsZURlZmluaXRpb24oZWxlbWVudCwgb3BhY2l0eSkge1xuICAgICAgICBsZXQgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIGlmICghZGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBncmFkaWVudFxuICAgICAgICBpZiAodHlwZW9mIGRlZi5jcmVhdGVHcmFkaWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiAnZ2V0Qm91bmRpbmdCb3gnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuY3JlYXRlR3JhZGllbnQodGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhdHRlcm5cbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlUGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5UcmFuc2Zvcm0gPSBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlZiAmJiBwYXR0ZXJuVHJhbnNmb3JtLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScsIHRydWUpLnNldFZhbHVlKHBhdHRlcm5UcmFuc2Zvcm0udmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLmNyZWF0ZVBhdHRlcm4odGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldFN0cmluZygpO1xuICAgICAgICByZXR1cm4gUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZ1trZXldIHx8IG51bGw7XG4gICAgfVxuICAgIGFkZE9wYWNpdHkob3BhY2l0eSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgbGV0IGNvbW1hcyA9IDA7XG4gICAgICAgIC8vIFNpbXVsYXRlIG9sZCBSR0JDb2xvciB2ZXJzaW9uLCB3aGljaCBjYW4ndCBwYXJzZSByZ2JhLlxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgaWYgKHZhbHVlW2ldID09PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBjb21tYXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tYXMgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3BhY2l0eS5oYXNWYWx1ZSgpICYmIHRoaXMuaXNTdHJpbmcoKSAmJiBjb21tYXMgIT09IDMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gbmV3IFJHQkNvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICAgICAgICAgIGNvbG9yLmFscGhhID0gb3BhY2l0eS5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgdGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBuYW1lLCB2YWx1ZSl7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gZmFsc2U7XG4gICAgfVxufVxuUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZyA9IHtcbiAgICAnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXG4gICAgJ2JlZm9yZS1lZGdlJzogJ3RvcCcsXG4gICAgJ3RleHQtYmVmb3JlLWVkZ2UnOiAndG9wJyxcbiAgICAnbWlkZGxlJzogJ21pZGRsZScsXG4gICAgJ2NlbnRyYWwnOiAnbWlkZGxlJyxcbiAgICAnYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAgICd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgICAnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxuICAgICdhbHBoYWJldGljJzogJ2FscGhhYmV0aWMnLFxuICAgICdoYW5naW5nJzogJ2hhbmdpbmcnLFxuICAgICdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcbn07XG5cbmNsYXNzIFZpZXdQb3J0IHtcbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgICB9XG4gICAgc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudmlld1BvcnRzLnB1c2goe1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUN1cnJlbnQoKSB7XG4gICAgICAgIHRoaXMudmlld1BvcnRzLnBvcCgpO1xuICAgIH1cbiAgICBnZXRSb290KCkge1xuICAgICAgICBjb25zdCBbcm9vdF0gPSB0aGlzLnZpZXdQb3J0cztcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBnZXRDdXJyZW50KCkge1xuICAgICAgICBjb25zdCB7IHZpZXdQb3J0cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB2aWV3UG9ydHNbdmlld1BvcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLndpZHRoO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkuaGVpZ2h0O1xuICAgIH1cbiAgICBjb21wdXRlU2l6ZShkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09PSAneCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09PSAneScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5oZWlnaHQsIDIpKSAvIE1hdGguc3FydCgyKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgICB9XG59XG5WaWV3UG9ydC5ERUZBVUxUX1ZJRVdQT1JUX1dJRFRIID0gODAwO1xuVmlld1BvcnQuREVGQVVMVF9WSUVXUE9SVF9IRUlHSFQgPSA2MDA7XG5mdW5jdGlvbiBnZXREZWZhdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBWaWV3UG9ydC5ERUZBVUxUX1ZJRVdQT1JUX1dJRFRILFxuICAgICAgICBoZWlnaHQ6IFZpZXdQb3J0LkRFRkFVTFRfVklFV1BPUlRfSEVJR0hUXG4gICAgfTtcbn1cblxuY2xhc3MgUG9pbnQge1xuICAgIHN0YXRpYyBwYXJzZShwb2ludCkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgICAgICBjb25zdCBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IGRlZmF1bHRWYWx1ZV0gPSB0b051bWJlcnMocG9pbnQpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VTY2FsZShzY2FsZSkge1xuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgICAgICBjb25zdCBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IHhdID0gdG9OdW1iZXJzKHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRvTnVtYmVycyhwYXRoKTtcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGF0aFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpe1xuICAgICAgICAgICAgcGF0aFBvaW50cy5wdXNoKG5ldyBQb2ludChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFBvaW50cztcbiAgICB9XG4gICAgYW5nbGVUbyhwb2ludCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludC55IC0gdGhpcy55LCBwb2ludC54IC0gdGhpcy54KTtcbiAgICB9XG4gICAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB4cCA9IHggKiB0cmFuc2Zvcm1bMF0gKyB5ICogdHJhbnNmb3JtWzJdICsgdHJhbnNmb3JtWzRdO1xuICAgICAgICBjb25zdCB5cCA9IHggKiB0cmFuc2Zvcm1bMV0gKyB5ICogdHJhbnNmb3JtWzNdICsgdHJhbnNmb3JtWzVdO1xuICAgICAgICB0aGlzLnggPSB4cDtcbiAgICAgICAgdGhpcy55ID0geXA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHgsIHkpe1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbn1cblxuY2xhc3MgTW91c2Uge1xuICAgIGlzV29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2luZztcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNjcmVlbiAsIG9uQ2xpY2sgLCBvbk1vdXNlTW92ZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHNjcmVlbi5jdHguY2FudmFzO1xuICAgICAgICBjYW52YXMub25jbGljayA9IG9uQ2xpY2s7XG4gICAgICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG9uTW91c2VNb3ZlO1xuICAgICAgICB0aGlzLndvcmtpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuc2NyZWVuLmN0eC5jYW52YXM7XG4gICAgICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgICAgICBjYW52YXMub25jbGljayA9IG51bGw7XG4gICAgICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgfVxuICAgIGhhc0V2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya2luZyAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBydW5FdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy53b3JraW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzY3JlZW46IGRvY3VtZW50ICwgZXZlbnRzICwgZXZlbnRFbGVtZW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3R5bGUgIH0gPSBkb2N1bWVudC5jdHguY2FudmFzO1xuICAgICAgICBsZXQgZWxlbWVudDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBldmVudHMuZm9yRWFjaCgocGFyYW0sIGkpPT57XG4gICAgICAgICAgICBsZXQgeyBydW4gIH0gPSBwYXJhbTtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBldmVudEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgd2hpbGUoZWxlbWVudCl7XG4gICAgICAgICAgICAgICAgcnVuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbmUgcnVubmluZywgY2xlYXJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudEVsZW1lbnRzID0gW107XG4gICAgfVxuICAgIGNoZWNrUGF0aChlbGVtZW50LCBjdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWN0eCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXZlbnRzICwgZXZlbnRFbGVtZW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChwYXJhbSwgaSk9PntcbiAgICAgICAgICAgIGxldCB7IHggLCB5ICB9ID0gcGFyYW07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGN0eC5pc1BvaW50SW5QYXRoICYmIGN0eC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjaGVja0JvdW5kaW5nQm94KGVsZW1lbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZXZlbnRzICwgZXZlbnRFbGVtZW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKChwYXJhbSwgaSk9PntcbiAgICAgICAgICAgIGxldCB7IHggLCB5ICB9ID0gcGFyYW07XG4gICAgICAgICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgYm91bmRpbmdCb3guaXNQb2ludEluQm94KHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBYWSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93ICwgY3R4ICB9ID0gdGhpcy5zY3JlZW47XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGN0eC5jYW52YXM7XG4gICAgICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICAgICAgcG9pbnQueCAtPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICBwb2ludC55IC09IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuc2Nyb2xsWCkge1xuICAgICAgICAgICAgcG9pbnQueCArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNjcm9sbFkpIHtcbiAgICAgICAgICAgIHBvaW50LnkgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzLm1hcFhZKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdvbmNsaWNrJyxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgcnVuIChldmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFRhcmdldC5vbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uQ2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnb25tb3VzZW1vdmUnLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBydW4gKGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NyZWVuKXtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgICAgIHRoaXMud29ya2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xuY29uc3QgZGVmYXVsdEZldGNoJDEgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnID8gZmV0Y2guYmluZCh1bmRlZmluZWQpIC8vIGBmZXRjaGAgZGVwZW5kcyBvbiBjb250ZXh0OiBgc29tZU9iamVjdC5mZXRjaCguLi4pYCB3aWxsIHRocm93IGVycm9yLlxuIDogdW5kZWZpbmVkO1xuY2xhc3MgU2NyZWVuIHtcbiAgICB3YWl0KGNoZWNrZXIpIHtcbiAgICAgICAgdGhpcy53YWl0cy5wdXNoKGNoZWNrZXIpO1xuICAgIH1cbiAgICByZWFkeSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgIGlmICghdGhpcy5yZWFkeVByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gICAgfVxuICAgIGlzUmVhZHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhZHlMb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1JlYWR5TG9jayA9IHRoaXMud2FpdHMuZXZlcnkoKF8pPT5fKClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGlzUmVhZHlMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLndhaXRzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBpc1JlYWR5TG9jaztcbiAgICAgICAgcmV0dXJuIGlzUmVhZHlMb2NrO1xuICAgIH1cbiAgICBzZXREZWZhdWx0cyhjdHgpIHtcbiAgICAgICAgLy8gaW5pdGlhbCB2YWx1ZXMgYW5kIGRlZmF1bHRzXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gNDtcbiAgICB9XG4gICAgc2V0Vmlld0JveChwYXJhbSkge1xuICAgICAgICBsZXQgeyBkb2N1bWVudCAsIGN0eCAsIGFzcGVjdFJhdGlvICwgd2lkdGggLCBkZXNpcmVkV2lkdGggLCBoZWlnaHQgLCBkZXNpcmVkSGVpZ2h0ICwgbWluWCA9MCAsIG1pblkgPTAgLCByZWZYICwgcmVmWSAsIGNsaXAgPWZhbHNlICwgY2xpcFggPTAgLCBjbGlwWSA9MCAgfSA9IHBhcmFtO1xuICAgICAgICAvLyBhc3BlY3QgcmF0aW8gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgICAgICBjb25zdCBjbGVhbkFzcGVjdFJhdGlvID0gY29tcHJlc3NTcGFjZXMoYXNwZWN0UmF0aW8pLnJlcGxhY2UoL15kZWZlclxccy8sICcnKSAvLyBpZ25vcmUgZGVmZXJcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBbYXNwZWN0UmF0aW9BbGlnbiwgYXNwZWN0UmF0aW9NZWV0T3JTbGljZV0gPSBjbGVhbkFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgICAgIGNvbnN0IGFsaWduID0gYXNwZWN0UmF0aW9BbGlnbiB8fCAneE1pZFlNaWQnO1xuICAgICAgICBjb25zdCBtZWV0T3JTbGljZSA9IGFzcGVjdFJhdGlvTWVldE9yU2xpY2UgfHwgJ21lZXQnO1xuICAgICAgICAvLyBjYWxjdWxhdGUgc2NhbGVcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gd2lkdGggLyBkZXNpcmVkV2lkdGg7XG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IGhlaWdodCAvIGRlc2lyZWRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICBjb25zdCBzY2FsZU1heCA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgbGV0IGZpbmFsRGVzaXJlZFdpZHRoID0gZGVzaXJlZFdpZHRoO1xuICAgICAgICBsZXQgZmluYWxEZXNpcmVkSGVpZ2h0ID0gZGVzaXJlZEhlaWdodDtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWluO1xuICAgICAgICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgICAgZmluYWxEZXNpcmVkV2lkdGggKj0gc2NhbGVNYXg7XG4gICAgICAgICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNYXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmWFByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZYJywgcmVmWCk7XG4gICAgICAgIGNvbnN0IHJlZllQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncmVmWScsIHJlZlkpO1xuICAgICAgICBjb25zdCBoYXNSZWZzID0gcmVmWFByb3AuaGFzVmFsdWUoKSAmJiByZWZZUHJvcC5oYXNWYWx1ZSgpO1xuICAgICAgICBpZiAoaGFzUmVmcykge1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc2NhbGVNaW4gKiByZWZYUHJvcC5nZXRQaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWVByb3AuZ2V0UGl4ZWxzKCd5JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRDbGlwWCA9IHNjYWxlTWluICogY2xpcFg7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRDbGlwWSA9IHNjYWxlTWluICogY2xpcFk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHNjYWxlZENsaXBYLCBzY2FsZWRDbGlwWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBzY2FsZWRDbGlwWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhzY2FsZWRDbGlwWCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNSZWZzKSB7XG4gICAgICAgICAgICBjb25zdCBpc01lZXRNaW5ZID0gbWVldE9yU2xpY2UgPT09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PT0gc2NhbGVZO1xuICAgICAgICAgICAgY29uc3QgaXNTbGljZU1heFkgPSBtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PT0gc2NhbGVZO1xuICAgICAgICAgICAgY29uc3QgaXNNZWV0TWluWCA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWDtcbiAgICAgICAgICAgIGNvbnN0IGlzU2xpY2VNYXhYID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWDtcbiAgICAgICAgICAgIGlmIChhbGlnbi5zdGFydHNXaXRoKCd4TWlkJykgJiYgKGlzTWVldE1pblkgfHwgaXNTbGljZU1heFkpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCAvIDIgLSBmaW5hbERlc2lyZWRXaWR0aCAvIDIsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWlkJykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyIC0gZmluYWxEZXNpcmVkSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ24uc3RhcnRzV2l0aCgneE1heCcpICYmIChpc01lZXRNaW5ZIHx8IGlzU2xpY2VNYXhZKSkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLSBmaW5hbERlc2lyZWRXaWR0aCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxpZ24uZW5kc1dpdGgoJ1lNYXgnKSAmJiAoaXNNZWV0TWluWCB8fCBpc1NsaWNlTWF4WCkpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAtIGZpbmFsRGVzaXJlZEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NhbGVcbiAgICAgICAgc3dpdGNoKHRydWUpe1xuICAgICAgICAgICAgY2FzZSBhbGlnbiA9PT0gJ25vbmUnOlxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnbWVldCc6XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlTWluLCBzY2FsZU1pbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnc2xpY2UnOlxuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYW5zbGF0ZVxuICAgICAgICBjdHgudHJhbnNsYXRlKC1taW5YLCAtbWluWSk7XG4gICAgfVxuICAgIHN0YXJ0KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHsgZW5hYmxlUmVkcmF3ID1mYWxzZSAsIGlnbm9yZU1vdXNlID1mYWxzZSAsIGlnbm9yZUFuaW1hdGlvbiA9ZmFsc2UgLCBpZ25vcmVEaW1lbnNpb25zID1mYWxzZSAsIGlnbm9yZUNsZWFyID1mYWxzZSAsIGZvcmNlUmVkcmF3ICwgc2NhbGVXaWR0aCAsIHNjYWxlSGVpZ2h0ICwgb2Zmc2V0WCAsIG9mZnNldFkgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgICBjb25zdCB7IG1vdXNlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IDEwMDAgLyBTY3JlZW4uRlJBTUVSQVRFO1xuICAgICAgICB0aGlzLmlzUmVhZHlMb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmFibGVSZWRyYXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHRoZW4gPSBub3c7XG4gICAgICAgIGxldCBkZWx0YSA9IDA7XG4gICAgICAgIGNvbnN0IHRpY2sgPSAoKT0+e1xuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGRlbHRhID0gbm93IC0gdGhlbjtcbiAgICAgICAgICAgIGlmIChkZWx0YSA+PSBmcmFtZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhlbiA9IG5vdyAtIGRlbHRhICUgZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRVcGRhdGUoaWdub3JlQW5pbWF0aW9uLCBmb3JjZVJlZHJhdykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgbW91c2UucnVuRXZlbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWlnbm9yZU1vdXNlKSB7XG4gICAgICAgICAgICBtb3VzZS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbmNlbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlLnN0b3AoKTtcbiAgICB9XG4gICAgc2hvdWxkVXBkYXRlKGlnbm9yZUFuaW1hdGlvbiwgZm9yY2VSZWRyYXcpIHtcbiAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSBhbmltYXRpb25zP1xuICAgICAgICBpZiAoIWlnbm9yZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBmcmFtZUR1cmF0aW9uICB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZTEgPSB0aGlzLmFuaW1hdGlvbnMucmVkdWNlKChzaG91bGRVcGRhdGUsIGFuaW1hdGlvbik9PmFuaW1hdGlvbi51cGRhdGUoZnJhbWVEdXJhdGlvbikgfHwgc2hvdWxkVXBkYXRlXG4gICAgICAgICAgICAsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVlZCB1cGRhdGUgZnJvbSByZWRyYXc/XG4gICAgICAgIGlmICh0eXBlb2YgZm9yY2VSZWRyYXcgPT09ICdmdW5jdGlvbicgJiYgZm9yY2VSZWRyYXcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHlMb2NrICYmIHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWVkIHVwZGF0ZSBmcm9tIG1vdXNlIGV2ZW50cz9cbiAgICAgICAgaWYgKHRoaXMubW91c2UuaGFzRXZlbnRzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICBjb25zdCB7IHZpZXdQb3J0ICwgY3R4ICwgaXNGaXJzdFJlbmRlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgIHZpZXdQb3J0LmNsZWFyKCk7XG4gICAgICAgIGlmIChjYW52YXMud2lkdGggJiYgY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgICAgdmlld1BvcnQuc2V0Q3VycmVudChjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuICAgICAgICBjb25zdCBoZWlnaHRTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuICAgICAgICBpZiAoIWlnbm9yZURpbWVuc2lvbnMgJiYgKGlzRmlyc3RSZW5kZXIgfHwgdHlwZW9mIHNjYWxlV2lkdGggIT09ICdudW1iZXInICYmIHR5cGVvZiBzY2FsZUhlaWdodCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAvLyBzZXQgY2FudmFzIHNpemVcbiAgICAgICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChjYW52YXMud2lkdGgsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChjYW52YXMuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY1dpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoIHx8IGNhbnZhcy53aWR0aDtcbiAgICAgICAgbGV0IGNIZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0IHx8IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGlmIChpZ25vcmVEaW1lbnNpb25zICYmIHdpZHRoU3R5bGUuaGFzVmFsdWUoKSAmJiBoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjV2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuICAgICAgICAgICAgY0hlaWdodCA9IGhlaWdodFN0eWxlLmdldFBpeGVscygneScpO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXRYID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZShvZmZzZXRYKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScsIHRydWUpLnNldFZhbHVlKG9mZnNldFkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGVXaWR0aCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3Qgdmlld0JveCA9IHRvTnVtYmVycyhlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgIGxldCB4UmF0aW8gPSAwO1xuICAgICAgICAgICAgbGV0IHlSYXRpbyA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjYWxlV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB4UmF0aW8gPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZpZXdCb3hbMl0gJiYgIWlzTmFOKHZpZXdCb3hbMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzY2FsZVdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NhbGVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB5UmF0aW8gPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKSAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlld0JveFszXSAmJiAhaXNOYU4odmlld0JveFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeVJhdGlvID0gdmlld0JveFszXSAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgheFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgeFJhdGlvID0geVJhdGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF5UmF0aW8pIHtcbiAgICAgICAgICAgICAgICB5UmF0aW8gPSB4UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKS5zZXRWYWx1ZShzY2FsZVdpZHRoKTtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKS5zZXRWYWx1ZShzY2FsZUhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgdHJhbnNmb3JtU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQodHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIFwiIHNjYWxlKFwiKS5jb25jYXQoMSAvIHhSYXRpbywgXCIsIFwiKS5jb25jYXQoMSAvIHlSYXRpbywgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciBhbmQgcmVuZGVyXG4gICAgICAgIGlmICghaWdub3JlQ2xlYXIpIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY1dpZHRoLCBjSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnJlbmRlcihjdHgpO1xuICAgICAgICBpZiAoaXNGaXJzdFJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoY3R4LCB7IGZldGNoID1kZWZhdWx0RmV0Y2gkMSAsIHdpbmRvdyA9ZGVmYXVsdFdpbmRvdyAgfSA9IHt9KXtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG4gICAgICAgIHRoaXMudmlld1BvcnQgPSBuZXcgVmlld1BvcnQoKTtcbiAgICAgICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgICAgIHRoaXMud2FpdHMgPSBbXTtcbiAgICAgICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5pc1JlYWR5TG9jayA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRmlyc3RSZW5kZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBudWxsO1xuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgaWYgKCFmZXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCAnZmV0Y2gnIGluICdnbG9iYWxUaGlzJywgcGxlYXNlIHByb3ZpZGUgaXQgdmlhIG9wdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgIH1cbn1cblNjcmVlbi5kZWZhdWx0V2luZG93ID0gZGVmYXVsdFdpbmRvdztcblNjcmVlbi5kZWZhdWx0RmV0Y2ggPSBkZWZhdWx0RmV0Y2gkMTtcblNjcmVlbi5GUkFNRVJBVEUgPSAzMDtcblNjcmVlbi5NQVhfVklSVFVBTF9QSVhFTFMgPSAzMDAwMDtcblxuY29uc3QgeyBkZWZhdWx0RmV0Y2ggIH0gPSBTY3JlZW47XG5jb25zdCBEZWZhdWx0RE9NUGFyc2VyID0gdHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBET01QYXJzZXIgOiB1bmRlZmluZWQ7XG5jbGFzcyBQYXJzZXIge1xuICAgIGFzeW5jIHBhcnNlKHJlc291cmNlKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZS5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnJvbVN0cmluZyhyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZChyZXNvdXJjZSk7XG4gICAgfVxuICAgIHBhcnNlRnJvbVN0cmluZyh4bWwpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IHRoaXMuRE9NUGFyc2VyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAnaW1hZ2Uvc3ZnK3htbCcpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBwYXJzZXJFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdO1xuICAgICAgICBpZiAocGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXJFcnJvci50ZXh0Q29udGVudCB8fCAnVW5rbm93biBwYXJzZSBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgYXN5bmMgbG9hZCh1cmwpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKHVybCk7XG4gICAgICAgIGNvbnN0IHhtbCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGcm9tU3RyaW5nKHhtbCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgZmV0Y2ggPWRlZmF1bHRGZXRjaCAsIERPTVBhcnNlciA9RGVmYXVsdERPTVBhcnNlciAgfSA9IHt9KXtcbiAgICAgICAgaWYgKCFmZXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCAnZmV0Y2gnIGluICdnbG9iYWxUaGlzJywgcGxlYXNlIHByb3ZpZGUgaXQgdmlhIG9wdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFET01QYXJzZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgJ0RPTVBhcnNlcicgaW4gJ2dsb2JhbFRoaXMnLCBwbGVhc2UgcHJvdmlkZSBpdCB2aWEgb3B0aW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgICAgIHRoaXMuRE9NUGFyc2VyID0gRE9NUGFyc2VyO1xuICAgIH1cbn1cblxuY2xhc3MgVHJhbnNsYXRlIHtcbiAgICBhcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMucG9pbnQ7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoeCB8fCAwLCB5IHx8IDApO1xuICAgIH1cbiAgICB1bmFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5wb2ludDtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtMSAqIHggfHwgMCwgLTEgKiB5IHx8IDApO1xuICAgIH1cbiAgICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICB4IHx8IDAsXG4gICAgICAgICAgICB5IHx8IDBcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF8sIHBvaW50KXtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RyYW5zbGF0ZSc7XG4gICAgICAgIHRoaXMucG9pbnQgPSBQb2ludC5wYXJzZShwb2ludCk7XG4gICAgfVxufVxuXG5jbGFzcyBSb3RhdGUge1xuICAgIGFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IGN4ICwgY3kgLCBvcmlnaW5YICwgb3JpZ2luWSAsIGFuZ2xlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUuZ2V0UmFkaWFucygpKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICAgIHVuYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgY3ggLCBjeSAsIG9yaWdpblggLCBvcmlnaW5ZICwgYW5nbGUgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0eCA9IGN4ICsgb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgY3R4LnJvdGF0ZSgtMSAqIGFuZ2xlLmdldFJhZGlhbnMoKSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgICBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgICAgY29uc3QgeyBjeCAsIGN5ICwgYW5nbGUgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByYWQgPSBhbmdsZS5nZXRSYWRpYW5zKCk7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBjeCB8fCAwLFxuICAgICAgICAgICAgY3kgfHwgMCAvLyB0aGlzLnAueVxuICAgICAgICBdKTtcbiAgICAgICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW1xuICAgICAgICAgICAgTWF0aC5jb3MocmFkKSxcbiAgICAgICAgICAgIE1hdGguc2luKHJhZCksXG4gICAgICAgICAgICAtTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgICAgIE1hdGguY29zKHJhZCksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMFxuICAgICAgICBdKTtcbiAgICAgICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW1xuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIC1jeCB8fCAwLFxuICAgICAgICAgICAgLWN5IHx8IDAgLy8gLXRoaXMucC55XG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgcm90YXRlLCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICB0aGlzLnR5cGUgPSAncm90YXRlJztcbiAgICAgICAgY29uc3QgbnVtYmVycyA9IHRvTnVtYmVycyhyb3RhdGUpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBudW1iZXJzWzBdKTtcbiAgICAgICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgICAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gICAgICAgIHRoaXMuY3ggPSBudW1iZXJzWzFdIHx8IDA7XG4gICAgICAgIHRoaXMuY3kgPSBudW1iZXJzWzJdIHx8IDA7XG4gICAgfVxufVxuXG5jbGFzcyBTY2FsZSB7XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgc2NhbGU6IHsgeCAsIHkgIH0gLCBvcmlnaW5YICwgb3JpZ2luWSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC5zY2FsZSh4LCB5IHx8IHgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gICAgdW5hcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBzY2FsZTogeyB4ICwgeSAgfSAsIG9yaWdpblggLCBvcmlnaW5ZICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyB4LCAxIC8geSB8fCB4KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICAgIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5zY2FsZTtcbiAgICAgICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW1xuICAgICAgICAgICAgeCB8fCAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB5IHx8IDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoXywgc2NhbGUsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzY2FsZSc7XG4gICAgICAgIGNvbnN0IHNjYWxlU2l6ZSA9IFBvaW50LnBhcnNlU2NhbGUoc2NhbGUpO1xuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBub2RlLWNhbnZhc1xuICAgICAgICBpZiAoc2NhbGVTaXplLnggPT09IDAgfHwgc2NhbGVTaXplLnkgPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlU2l6ZS54ID0gUFNFVURPX1pFUk87XG4gICAgICAgICAgICBzY2FsZVNpemUueSA9IFBTRVVET19aRVJPO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZVNpemU7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgIH1cbn1cblxuY2xhc3MgTWF0cml4IHtcbiAgICBhcHBseShjdHgpIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW5YICwgb3JpZ2luWSAsIG1hdHJpeCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgICB1bmFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IG9yaWdpblggLCBvcmlnaW5ZICwgbWF0cml4ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYSA9IG1hdHJpeFswXTtcbiAgICAgICAgY29uc3QgYiA9IG1hdHJpeFsyXTtcbiAgICAgICAgY29uc3QgYyA9IG1hdHJpeFs0XTtcbiAgICAgICAgY29uc3QgZCA9IG1hdHJpeFsxXTtcbiAgICAgICAgY29uc3QgZSA9IG1hdHJpeFszXTtcbiAgICAgICAgY29uc3QgZiA9IG1hdHJpeFs1XTtcbiAgICAgICAgY29uc3QgZyA9IDA7XG4gICAgICAgIGNvbnN0IGggPSAwO1xuICAgICAgICBjb25zdCBpID0gMTtcbiAgICAgICAgY29uc3QgZGV0ID0gMSAvIChhICogKGUgKiBpIC0gZiAqIGgpIC0gYiAqIChkICogaSAtIGYgKiBnKSArIGMgKiAoZCAqIGggLSBlICogZykpO1xuICAgICAgICBjb25zdCB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKGRldCAqIChlICogaSAtIGYgKiBoKSwgZGV0ICogKGYgKiBnIC0gZCAqIGkpLCBkZXQgKiAoYyAqIGggLSBiICogaSksIGRldCAqIChhICogaSAtIGMgKiBnKSwgZGV0ICogKGIgKiBmIC0gYyAqIGUpLCBkZXQgKiAoYyAqIGQgLSBhICogZikpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gICAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKHRoaXMubWF0cml4KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoXywgbWF0cml4LCB0cmFuc2Zvcm1PcmlnaW4pe1xuICAgICAgICB0aGlzLnR5cGUgPSAnbWF0cml4JztcbiAgICAgICAgdGhpcy5tYXRyaXggPSB0b01hdHJpeFZhbHVlKG1hdHJpeCk7XG4gICAgICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICAgIH1cbn1cblxuY2xhc3MgU2tldyBleHRlbmRzIE1hdHJpeCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2tldyc7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdhbmdsZScsIHNrZXcpO1xuICAgIH1cbn1cblxuY2xhc3MgU2tld1ggZXh0ZW5kcyBTa2V3IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgICAgIHRoaXMudHlwZSA9ICdza2V3WCc7XG4gICAgICAgIHRoaXMubWF0cml4ID0gW1xuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBNYXRoLnRhbih0aGlzLmFuZ2xlLmdldFJhZGlhbnMoKSksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmNsYXNzIFNrZXdZIGV4dGVuZHMgU2tldyB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbil7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc2tld1knO1xuICAgICAgICB0aGlzLm1hdHJpeCA9IFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICBNYXRoLnRhbih0aGlzLmFuZ2xlLmdldFJhZGlhbnMoKSksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwXG4gICAgICAgIF07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRyYW5zZm9ybSkudHJpbSgpLnJlcGxhY2UoL1xcKShbYS16QS1aXSkvZywgJykgJDEnKS5yZXBsYWNlKC9cXCkoXFxzPyxcXHM/KS9nLCAnKSAnKS5zcGxpdCgvXFxzKD89W2Etel0pLyk7XG59XG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBbdHlwZSA9ICcnLCB2YWx1ZSA9ICcnXSA9IHRyYW5zZm9ybS5zcGxpdCgnKCcpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHR5cGUudHJpbSgpLFxuICAgICAgICB2YWx1ZS50cmltKCkucmVwbGFjZSgnKScsICcnKVxuICAgIF07XG59XG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIHN0YXRpYyBmcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFt0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHksIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSA9IHRyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eV0gPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLnNwbGl0KCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5ICYmIHRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybU9yaWdpbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKGRvY3VtZW50LCB0cmFuc2Zvcm1TdHlsZS5nZXRTdHJpbmcoKSwgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXBwbHkoY3R4KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3Jtcy5mb3JFYWNoKCh0cmFuc2Zvcm0pPT50cmFuc2Zvcm0uYXBwbHkoY3R4KVxuICAgICAgICApO1xuICAgIH1cbiAgICB1bmFwcGx5KGN0eCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaCgodHJhbnNmb3JtKT0+dHJhbnNmb3JtLnVuYXBwbHkoY3R4KVxuICAgICAgICApO1xuICAgIH1cbiAgICAvLyBUT0RPOiBhcHBseVRvUG9pbnQgdW51c2VkIC4uLiByZW1vdmU/XG4gICAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3Jtcy5mb3JFYWNoKCh0cmFuc2Zvcm0pPT50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KHBvaW50KVxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgdHJhbnNmb3JtMSwgdHJhbnNmb3JtT3JpZ2luKXtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcnNlVHJhbnNmb3Jtcyh0cmFuc2Zvcm0xKTtcbiAgICAgICAgZGF0YS5mb3JFYWNoKCh0cmFuc2Zvcm0pPT57XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGNvbnN0IFRyYW5zZm9ybVR5cGUgPSBUcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXNbdHlwZV07XG4gICAgICAgICAgICBpZiAoVHJhbnNmb3JtVHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKG5ldyBUcmFuc2Zvcm1UeXBlKHRoaXMuZG9jdW1lbnQsIHZhbHVlLCB0cmFuc2Zvcm1PcmlnaW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzID0ge1xuICAgIHRyYW5zbGF0ZTogVHJhbnNsYXRlLFxuICAgIHJvdGF0ZTogUm90YXRlLFxuICAgIHNjYWxlOiBTY2FsZSxcbiAgICBtYXRyaXg6IE1hdHJpeCxcbiAgICBza2V3WDogU2tld1gsXG4gICAgc2tld1k6IFNrZXdZXG59O1xuXG5jbGFzcyBFbGVtZW50IHtcbiAgICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBsZXQgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBhdHRyID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAoIWF0dHIgJiYgY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgbmFtZSwgJycpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gYXR0cjtcbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyIHx8IFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICAgIH1cbiAgICBnZXRIcmVmQXR0cmlidXRlKCkge1xuICAgICAgICBsZXQgaHJlZjtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpe1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnIHx8IGtleS5lbmRzV2l0aCgnOmhyZWYnKSkge1xuICAgICAgICAgICAgICAgIGhyZWYgPSB0aGlzLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHJlZiB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0U3R5bGUobmFtZSkge1xuICAgICAgICBsZXQgY3JlYXRlSWZOb3RFeGlzdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlLCBza2lwQW5jZXN0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLnN0eWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBpZiAoYXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IGF0dHIgLy8gbW92ZSB1cCB0byBtZSB0byBjYWNoZVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmV0dXJuIGF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50U3R5bGUgPSBwYXJlbnQuZ2V0U3R5bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsIG5hbWUsICcnKTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGU7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICAgIH1cbiAgICByZW5kZXIoY3R4KSB7XG4gICAgICAgIC8vIGRvbid0IHJlbmRlciBkaXNwbGF5PW5vbmVcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHZpc2liaWxpdHk9aGlkZGVuXG4gICAgICAgIGlmICh0aGlzLmdldFN0eWxlKCdkaXNwbGF5JykuZ2V0U3RyaW5nKCkgPT09ICdub25lJyB8fCB0aGlzLmdldFN0eWxlKCd2aXNpYmlsaXR5JykuZ2V0U3RyaW5nKCkgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gdGhpcy5nZXRTdHlsZSgnbWFzaycpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgICAgICAgICBtYXNrLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5nZXRTdHlsZSgnZmlsdGVyJykuZ2V0VmFsdWUoJ25vbmUnKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmdldFN0eWxlKCdmaWx0ZXInKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTtcbiAgICAgICAgICAgICAgICBmaWx0ZXIuYXBwbHkoY3R4LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBzZXRDb250ZXh0KF8pIHtcbiAgICAvLyBOTyBSRU5ERVJcbiAgICB9XG4gICAgYXBwbHlFZmZlY3RzKGN0eCkge1xuICAgICAgICAvLyB0cmFuc2Zvcm1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gVHJhbnNmb3JtLmZyb21FbGVtZW50KHRoaXMuZG9jdW1lbnQsIHRoaXMpO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGlwXG4gICAgICAgIGNvbnN0IGNsaXBQYXRoU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnY2xpcC1wYXRoJywgZmFsc2UsIHRydWUpO1xuICAgICAgICBpZiAoY2xpcFBhdGhTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgY29uc3QgY2xpcCA9IGNsaXBQYXRoU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgICAgICAgY2xpcC5hcHBseShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyQ29udGV4dChfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKT0+e1xuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRDaGlsZChjaGlsZE5vZGUpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ID8gY2hpbGROb2RlIDogdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGNoaWxkTm9kZSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGlmICghRWxlbWVudC5pZ25vcmVDaGlsZFR5cGVzLmluY2x1ZGVzKGNoaWxkLnR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBjb25zdCB7IG5vZGUgIH0gPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3R5bGVDbGFzc2VzID0gKHJlZiA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jYWxsKG5vZGUsICdjbGFzcycpO1xuICAgICAgICBpZiAoIXN0eWxlQ2xhc3NlcyB8fCBzdHlsZUNsYXNzZXMgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlQ2xhc3Nlcy5zcGxpdCgnICcpLnNvbWUoKHN0eWxlQ2xhc3MpPT5cIi5cIi5jb25jYXQoc3R5bGVDbGFzcykgPT09IHNlbGVjdG9yXG4gICAgICAgICk7XG4gICAgfVxuICAgIGFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgc3R5bGVzICwgc3R5bGVzU3BlY2lmaWNpdHkgIH0gPSB0aGlzLmRvY3VtZW50O1xuICAgICAgICBsZXQgc3R5bGVQcm9wO1xuICAgICAgICBmb3IoY29uc3Qgc2VsZWN0b3IgaW4gc3R5bGVzKXtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQCcpICYmIHRoaXMubWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVjaWZpY2l0eSA9IHN0eWxlc1NwZWNpZmljaXR5W3NlbGVjdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKGNvbnN0IG5hbWUgaW4gc3R5bGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV4aXN0aW5nU3BlY2lmaWNpdHkgPSB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGlzdGluZ1NwZWNpZmljaXR5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSAnMDAwJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpY2l0eSAmJiBzcGVjaWZpY2l0eSA+PSBleGlzdGluZ1NwZWNpZmljaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVQcm9wID0gc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IHN0eWxlUHJvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXSA9IHNwZWNpZmljaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVTdHlsZXMpIHtcbiAgICAgICAgY29uc3QgdG9SZXN0b3JlMSA9IGlnbm9yZVN0eWxlcy5yZWR1Y2UoKHRvUmVzdG9yZSwgbmFtZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlUHJvcCA9IGVsZW1lbnQuZ2V0U3R5bGUobmFtZSk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvUmVzdG9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgICAgICAgc3R5bGVQcm9wLnNldFZhbHVlKCcnKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4udG9SZXN0b3JlLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiB0b1Jlc3RvcmUxO1xuICAgIH1cbiAgICByZXN0b3JlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaCgocGFyYW0pPT57XG4gICAgICAgICAgICBsZXQgW25hbWUsIHZhbHVlXSA9IHBhcmFtO1xuICAgICAgICAgICAgZWxlbWVudC5nZXRTdHlsZShuYW1lLCB0cnVlKS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc0ZpcnN0Q2hpbGQoKSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIHJldHVybiAoKHJlZiA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5jaGlsZHJlbi5pbmRleE9mKHRoaXMpKSA9PT0gMDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMgPSBmYWxzZSl7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gY2FwdHVyZVRleHROb2RlcztcbiAgICAgICAgdGhpcy50eXBlID0gJyc7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0ge307XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSAnJztcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGF0dHJpYnV0ZXNcbiAgICAgICAgQXJyYXkuZnJvbShub2RlLmF0dHJpYnV0ZXMpLmZvckVhY2goKGF0dHJpYnV0ZSk9PntcbiAgICAgICAgICAgIGNvbnN0IG5vZGVOYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW25vZGVOYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbm9kZU5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcbiAgICAgICAgLy8gYWRkIGlubGluZSBzdHlsZXNcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpLmdldFN0cmluZygpLnNwbGl0KCc7JykubWFwKChfKT0+Xy50cmltKClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdHlsZXMuZm9yRWFjaCgoc3R5bGUpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBzdHlsZS5zcGxpdCgnOicpLm1hcCgoXyk9Pl8udHJpbSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZGVmaW5pdGlvbnMgIH0gPSBkb2N1bWVudDtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgLy8gYWRkIGlkXG4gICAgICAgIGlmIChpZC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluaXRpb25zW2lkLmdldFN0cmluZygpXSkge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zW2lkLmdldFN0cmluZygpXSA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goKGNoaWxkTm9kZSk9PntcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkTm9kZSkgLy8gRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlVGV4dE5vZGVzICYmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUuZ2V0VGV4dCgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZCh0ZXh0Tm9kZSkgLy8gVEVYVF9OT0RFXG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcyA9IFtcbiAgICAndGl0bGUnXG5dO1xuXG5jbGFzcyBVbmtub3duRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gd3JhcEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBmb250RmFtaWx5LnRyaW0oKTtcbiAgICByZXR1cm4gL14oJ3xcIikvLnRlc3QodHJpbW1lZCkgPyB0cmltbWVkIDogXCJcXFwiXCIuY29uY2F0KHRyaW1tZWQsIFwiXFxcIlwiKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnID8gZm9udEZhbWlseSA6IGZvbnRGYW1pbHkudHJpbSgpLnNwbGl0KCcsJykubWFwKHdyYXBGb250RmFtaWx5KS5qb2luKCcsJyk7XG59XG4vKipcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXN0eWxlXG4gKiBAcGFyYW0gZm9udFN0eWxlXG4gKiBAcmV0dXJucyBDU1MgZm9udCBzdHlsZS5cbiAqLyBmdW5jdGlvbiBwcmVwYXJlRm9udFN0eWxlKGZvbnRTdHlsZSkge1xuICAgIGlmICghZm9udFN0eWxlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0Rm9udFN0eWxlID0gZm9udFN0eWxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCh0YXJnZXRGb250U3R5bGUpe1xuICAgICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICBjYXNlICdpdGFsaWMnOlxuICAgICAgICBjYXNlICdvYmxpcXVlJzpcbiAgICAgICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgICAgICBjYXNlICd1bnNldCc6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKC9eb2JsaXF1ZVxccysoLXwpXFxkK2RlZyQvLnRlc3QodGFyZ2V0Rm9udFN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC13ZWlnaHRcbiAqIEBwYXJhbSBmb250V2VpZ2h0XG4gKiBAcmV0dXJucyBDU1MgZm9udCB3ZWlnaHQuXG4gKi8gZnVuY3Rpb24gcHJlcGFyZUZvbnRXZWlnaHQoZm9udFdlaWdodCkge1xuICAgIGlmICghZm9udFdlaWdodCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEZvbnRXZWlnaHQgPSBmb250V2VpZ2h0LnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCh0YXJnZXRGb250V2VpZ2h0KXtcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgY2FzZSAnYm9sZCc6XG4gICAgICAgIGNhc2UgJ2xpZ2h0ZXInOlxuICAgICAgICBjYXNlICdib2xkZXInOlxuICAgICAgICBjYXNlICdpbmhlcml0JzpcbiAgICAgICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgICAgIGNhc2UgJ3Vuc2V0JzpcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRGb250V2VpZ2h0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKC9eW1xcZC5dKyQvLnRlc3QodGFyZ2V0Rm9udFdlaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFdlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5jbGFzcyBGb250IHtcbiAgICBzdGF0aWMgcGFyc2UoKSB7XG4gICAgICAgIGxldCBmb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiAnJywgaW5oZXJpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdm9pZCAwO1xuICAgICAgICBsZXQgZm9udFN0eWxlID0gJyc7XG4gICAgICAgIGxldCBmb250VmFyaWFudCA9ICcnO1xuICAgICAgICBsZXQgZm9udFdlaWdodCA9ICcnO1xuICAgICAgICBsZXQgZm9udFNpemUgPSAnJztcbiAgICAgICAgbGV0IGZvbnRGYW1pbHkgPSAnJztcbiAgICAgICAgY29uc3QgcGFydHMgPSBjb21wcmVzc1NwYWNlcyhmb250KS50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgY29uc3Qgc2V0ID0ge1xuICAgICAgICAgICAgZm9udFNpemU6IGZhbHNlLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBmYWxzZSxcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgZm9udFZhcmlhbnQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHBhcnRzLmZvckVhY2goKHBhcnQpPT57XG4gICAgICAgICAgICBzd2l0Y2godHJ1ZSl7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRTdHlsZSAmJiBGb250LnN0eWxlcy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRWYXJpYW50ICYmIEZvbnQudmFyaWFudHMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRWYXJpYW50ID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAhc2V0LmZvbnRXZWlnaHQgJiYgRm9udC53ZWlnaHRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0ID0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LmZvbnRXZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICFzZXQuZm9udFNpemU6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplID0gcGFydC5zcGxpdCgnLycpWzBdIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQuZm9udFdlaWdodCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldC5mb250U2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgKz0gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBGb250KGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwcmVwYXJlRm9udFN0eWxlKHRoaXMuZm9udFN0eWxlKSxcbiAgICAgICAgICAgIHRoaXMuZm9udFZhcmlhbnQsXG4gICAgICAgICAgICBwcmVwYXJlRm9udFdlaWdodCh0aGlzLmZvbnRXZWlnaHQpLFxuICAgICAgICAgICAgdGhpcy5mb250U2l6ZSxcbiAgICAgICAgICAgIC8vIFdyYXAgZm9udEZhbWlseSBvbmx5IG9uIG5vZGVqcyBhbmQgb25seSBmb3IgY2FudmFzLmN0eFxuICAgICAgICAgICAgcHJlcGFyZUZvbnRGYW1pbHkodGhpcy5mb250RmFtaWx5KVxuICAgICAgICBdLmpvaW4oJyAnKS50cmltKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KXtcbiAgICAgICAgY29uc3QgaW5oZXJpdEZvbnQgPSBpbmhlcml0ID8gdHlwZW9mIGluaGVyaXQgPT09ICdzdHJpbmcnID8gRm9udC5wYXJzZShpbmhlcml0KSA6IGluaGVyaXQgOiB7fTtcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCBpbmhlcml0Rm9udC5mb250RmFtaWx5O1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gZm9udFNpemUgfHwgaW5oZXJpdEZvbnQuZm9udFNpemU7XG4gICAgICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlIHx8IGluaGVyaXRGb250LmZvbnRTdHlsZTtcbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gZm9udFdlaWdodCB8fCBpbmhlcml0Rm9udC5mb250V2VpZ2h0O1xuICAgICAgICB0aGlzLmZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQgfHwgaW5oZXJpdEZvbnQuZm9udFZhcmlhbnQ7XG4gICAgfVxufVxuRm9udC5zdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xuRm9udC52YXJpYW50cyA9ICdub3JtYWx8c21hbGwtY2Fwc3xpbmhlcml0JztcbkZvbnQud2VpZ2h0cyA9ICdub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMHxpbmhlcml0JztcblxuY2xhc3MgQm91bmRpbmdCb3gge1xuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy54MTtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnkxO1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbiAgICB9XG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICAgIH1cbiAgICBhZGRQb2ludCh4LCB5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLngyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkWCh4KSB7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeCwgMCk7XG4gICAgfVxuICAgIGFkZFkoeSkge1xuICAgICAgICB0aGlzLmFkZFBvaW50KDAsIHkpO1xuICAgIH1cbiAgICBhZGRCb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgICAgICBpZiAoIWJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB4MSAsIHkxICwgeDIgLCB5MiAgfSA9IGJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeDIsIHkyKTtcbiAgICB9XG4gICAgc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHAwICsgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiBwMiArIE1hdGgucG93KHQsIDMpICogcDM7XG4gICAgfVxuICAgIGJlemllckN1cnZlQWRkKGZvclgsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIGNvbnN0IGIgPSA2ICogcDAgLSAxMiAqIHAxICsgNiAqIHAyO1xuICAgICAgICBjb25zdCBhID0gLTMgKiBwMCArIDkgKiBwMSAtIDkgKiBwMiArIDMgKiBwMztcbiAgICAgICAgY29uc3QgYyA9IDMgKiBwMSAtIDMgKiBwMDtcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChiID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuICAgICAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0MSwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDEsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICAgICAgdGhpcy5hZGRQb2ludChwMHgsIHAweSk7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQocDN4LCBwM3kpO1xuICAgICAgICB0aGlzLmJlemllckN1cnZlQWRkKHRydWUsIHAweCwgcDF4LCBwMngsIHAzeCk7XG4gICAgICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQoZmFsc2UsIHAweSwgcDF5LCBwMnksIHAzeSk7XG4gICAgfVxuICAgIGFkZFF1YWRyYXRpY0N1cnZlKHAweCwgcDB5LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAgICAgY29uc3QgY3AxeCA9IHAweCArIDIgLyAzICogKHAxeCAtIHAweCkgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcbiAgICAgICAgO1xuICAgICAgICBjb25zdCBjcDF5ID0gcDB5ICsgMiAvIDMgKiAocDF5IC0gcDB5KSAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNwMnggPSBjcDF4ICsgMSAvIDMgKiAocDJ4IC0gcDB4KSAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAocDJ5IC0gcDB5KSAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuICAgICAgICA7XG4gICAgICAgIHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksIGNwMnksIHAyeCwgcDJ5KTtcbiAgICB9XG4gICAgaXNQb2ludEluQm94KHgsIHkpIHtcbiAgICAgICAgY29uc3QgeyB4MSAsIHkxICwgeDIgLCB5MiAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih4MSA9IE51bWJlci5OYU4sIHkxID0gTnVtYmVyLk5hTiwgeDIgPSBOdW1iZXIuTmFOLCB5MiA9IE51bWJlci5OYU4pe1xuICAgICAgICB0aGlzLngxID0geDE7XG4gICAgICAgIHRoaXMueTEgPSB5MTtcbiAgICAgICAgdGhpcy54MiA9IHgyO1xuICAgICAgICB0aGlzLnkyID0geTI7XG4gICAgICAgIHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcbiAgICAgICAgdGhpcy5hZGRQb2ludCh4MiwgeTIpO1xuICAgIH1cbn1cblxuY2xhc3MgUmVuZGVyZWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY2FsY3VsYXRlT3BhY2l0eSgpIHtcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlKGVsZW1lbnQpe1xuICAgICAgICAgICAgY29uc3Qgb3BhY2l0eVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnb3BhY2l0eScsIGZhbHNlLCB0cnVlKSAvLyBubyBhbmNlc3RvcnMgb24gc3R5bGUgY2FsbFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG9wYWNpdHlTdHlsZS5oYXNWYWx1ZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgIG9wYWNpdHkgKj0gb3BhY2l0eVN0eWxlLmdldE51bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGFjaXR5O1xuICAgIH1cbiAgICBzZXRDb250ZXh0KGN0eCkge1xuICAgICAgICBsZXQgZnJvbU1lYXN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAgICAgICAvLyBmaWxsXG4gICAgICAgICAgICBjb25zdCBmaWxsU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbCcpO1xuICAgICAgICAgICAgY29uc3QgZmlsbE9wYWNpdHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLW9wYWNpdHknKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZScpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlT3BhY2l0eVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utb3BhY2l0eScpO1xuICAgICAgICAgICAgaWYgKGZpbGxTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgZmlsbE9wYWNpdHlTdHlsZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGxTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxsU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICBmaWxsU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxTdHlsZSA9IGZpbGxTdHlsZVByb3AuZ2V0Q29sb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsbFN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogZmlsbFN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsT3BhY2l0eVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFN0eWxlID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgY3R4LmZpbGxTdHlsZSkuYWRkT3BhY2l0eShmaWxsT3BhY2l0eVN0eWxlUHJvcCkuZ2V0Q29sb3IoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3Ryb2tlXG4gICAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCBzdHJva2VPcGFjaXR5UHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZVByb3Auc2V0VmFsdWUodGhpcy5nZXRTdHlsZSgnY29sb3InKS5nZXRDb2xvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZVN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IHN0cm9rZVN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIGN0eC5zdHJva2VTdHlsZSkuYWRkT3BhY2l0eShzdHJva2VPcGFjaXR5UHJvcCkuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJva2VXaWR0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS13aWR0aCcpO1xuICAgICAgICAgICAgaWYgKHN0cm9rZVdpZHRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMaW5lV2lkdGggPSBzdHJva2VXaWR0aFN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gIW5ld0xpbmVXaWR0aCA/IFBTRVVET19aRVJPIC8vIGJyb3dzZXJzIGRvbid0IHJlc3BlY3QgMCAob3Igbm9kZS1jYW52YXM/IDotKVxuICAgICAgICAgICAgICAgICA6IG5ld0xpbmVXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUxpbmVjYXBTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWNhcCcpO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWpvaW4nKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZU1pdGVybGltaXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKTtcbiAgICAgICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICAgICAgLy8gY29uc3QgcG9pbnRPcmRlclN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3BhaW50LW9yZGVyJyk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBzdHJva2VEYXNob2Zmc2V0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG4gICAgICAgICAgICBpZiAoc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSBzdHJva2VMaW5lY2FwU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBzdHJva2VMaW5lam9pblN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJva2VNaXRlcmxpbWl0UHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBzdHJva2VNaXRlcmxpbWl0UHJvcC5nZXROdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5FRUQgVEVTVFxuICAgICAgICAgICAgLy8gaWYgKHBvaW50T3JkZXJTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgLy8gICAvLyA/XG4gICAgICAgICAgICAvLyAgIGN0eC5wYWludE9yZGVyID0gcG9pbnRPcmRlclN0eWxlUHJvcC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5oYXNWYWx1ZSgpICYmIHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwcyA9IHRvTnVtYmVycyhzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goZ2Fwcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoID0gZ2FwcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaCAhPT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aCA9PT0gMSAmJiBnYXBzWzBdID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICAgICAgY3R4Lm1vekRhc2ggPSBnYXBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzdHJva2VEYXNob2Zmc2V0UHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5saW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmb250XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZm9udFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTdHlsZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRWYXJpYW50U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC12YXJpYW50Jyk7XG4gICAgICAgICAgICBjb25zdCBmb250V2VpZ2h0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC13ZWlnaHQnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zaXplJyk7XG4gICAgICAgICAgICBjb25zdCBmb250RmFtaWx5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udChmb250U3R5bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRWYXJpYW50U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250V2VpZ2h0U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250U2l6ZVN0eWxlUHJvcC5oYXNWYWx1ZSgpID8gXCJcIi5jb25jYXQoZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKHRydWUpLCBcInB4XCIpIDogJycsIGZvbnRGYW1pbHlTdHlsZVByb3AuZ2V0U3RyaW5nKCksIEZvbnQucGFyc2UoZm9udFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgY3R4LmZvbnQpKTtcbiAgICAgICAgICAgIGZvbnRTdHlsZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTdHlsZSk7XG4gICAgICAgICAgICBmb250VmFyaWFudFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRWYXJpYW50KTtcbiAgICAgICAgICAgIGZvbnRXZWlnaHRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250V2VpZ2h0KTtcbiAgICAgICAgICAgIGZvbnRTaXplU3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFNpemUpO1xuICAgICAgICAgICAgZm9udEZhbWlseVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRGYW1pbHkpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZm9udFNpemVTdHlsZVByb3AuaXNQaXhlbHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuZW1TaXplID0gZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyb21NZWFzdXJlKSB7XG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpO1xuICAgICAgICAgICAgLy8gb3BhY2l0eVxuICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJDb250ZXh0KGN0eCkge1xuICAgICAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgICAgaWYgKHRoaXMubW9kaWZpZWRFbVNpemVTdGFjaykge1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5wb3BFbVNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgVGV4dEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHNldENvbnRleHQoY3R4KSB7XG4gICAgICAgIGxldCBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICAgIHN1cGVyLnNldENvbnRleHQoY3R4LCBmcm9tTWVhc3VyZSk7XG4gICAgICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IHRoaXMuZ2V0U3R5bGUoJ2RvbWluYW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgdGhpcy5nZXRTdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykuZ2V0VGV4dEJhc2VsaW5lKCk7XG4gICAgICAgIGlmICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLmxlYWZUZXh0cyA9IFtdO1xuICAgICAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgfVxuICAgIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJzdCwgY2FsY3VsYXRlIGNoaWxkIHBvc2l0aW9uc1xuICAgICAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KTtcbiAgICAgICAgbGV0IGJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICAgICAgLy8gdGhlbiBjYWxjdWxhdGUgYm91bmRpbmcgYm94XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQm91bmRpbmdCb3ggPSB0aGlzLmdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICAgICAgICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveCA9IGNoaWxkQm91bmRpbmdCb3g7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBnZXRGb250U2l6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGluaGVyaXRGb250U2l6ZSA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpLmZvbnRTaXplO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGluaGVyaXRGb250U2l6ZSk7XG4gICAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9XG4gICAgZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnkgLSBmb250U2l6ZSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpO1xuICAgIH1cbiAgICBnZXRHbHlwaChmb250LCB0ZXh0LCBpKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgICAgICBsZXQgZ2x5cGg7XG4gICAgICAgIGlmIChmb250LmlzQXJhYmljKSB7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwcmV2Q2hhciA9IHRleHRbaSAtIDFdO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICAgIGxldCBhcmFiaWNGb3JtID0gJ2lzb2xhdGVkJztcbiAgICAgICAgICAgIGlmICgoaSA9PT0gMCB8fCBwcmV2Q2hhciA9PT0gJyAnKSAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYXJhYmljRm9ybSA9ICd0ZXJtaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYXJhYmljRm9ybSA9ICdtZWRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgKGkgPT09IGxlbiAtIDEgfHwgbmV4dENoYXIgPT09ICcgJykpIHtcbiAgICAgICAgICAgICAgICBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2x5cGggPSAoKHJlZiA9IGZvbnQuYXJhYmljR2x5cGhzW2NoYXJdKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZlthcmFiaWNGb3JtXSkgfHwgZm9udC5nbHlwaHNbY2hhcl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgICAgIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH1cbiAgICBnZXRUZXh0KCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGdldFRleHRGcm9tTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gbm9kZSB8fCB0aGlzLm5vZGU7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHRleHROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY2hpbGROb2Rlcy5pbmRleE9mKHRleHROb2RlKTtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgdGV4dCA9IGNvbXByZXNzU3BhY2VzKC8vIHRleHROb2RlLnZhbHVlXG4gICAgICAgIC8vIHx8IHRleHROb2RlLnRleHRcbiAgICAgICAgdGV4dE5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHRleHQgPSB0cmltTGVmdCh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgdGV4dCA9IHRyaW1SaWdodCh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29vcmRpbmF0ZXMoKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCk7XG4gICAgICAgIC8vIHRoZW4gcmVuZGVyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hpbGQoY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgbW91c2UgIH0gPSB0aGlzLmRvY3VtZW50LnNjcmVlbjtcbiAgICAgICAgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuICAgICAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgICAgICAgIG1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgdGhpcy5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgcGFyZW50ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBjdXN0b21Gb250ID0gcGFyZW50LmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdW5pdHNQZXJFbSAgfSA9IGN1c3RvbUZvbnQuZm9udEZhY2U7XG4gICAgICAgICAgICBjb25zdCBjdHhGb250ID0gRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCk7XG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGN0eEZvbnQuZm9udFNpemUpO1xuICAgICAgICAgICAgY29uc3QgZm9udFN0eWxlID0gcGFyZW50LmdldFN0eWxlKCdmb250LXN0eWxlJykuZ2V0U3RyaW5nKGN0eEZvbnQuZm9udFN0eWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGN1c3RvbUZvbnQuaXNSVEwgPyByZW5kZXJUZXh0LnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJykgOiByZW5kZXJUZXh0O1xuICAgICAgICAgICAgY29uc3QgZHggPSB0b051bWJlcnMocGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZSwgLXNjYWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsdyA9IGN0eC5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGN0eC5saW5lV2lkdGggKiB1bml0c1BlckVtIC8gZm9udFNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLjQsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbHlwaC5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoZm9udFN0eWxlID09PSAnaXRhbGljJykge1xuICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIC0wLjQsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZSwgLTEgLyBzY2FsZSk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTtcbiAgICAgICAgICAgICAgICB0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIHVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKz0gZHhbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSB0aGlzO1xuICAgICAgICAvLyBORUVEIFRFU1RcbiAgICAgICAgLy8gaWYgKGN0eC5wYWludE9yZGVyID09PSAnc3Ryb2tlJykge1xuICAgICAgICAvLyAgIGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgLy8gICAgIGN0eC5zdHJva2VUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gICBpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgICAgICAvLyAgICAgY3R4LmZpbGxUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChyZW5kZXJUZXh0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIC8vIH1cbiAgICB9XG4gICAgYXBwbHlBbmNob3JpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRDaHVua1N0YXJ0ID49IHRoaXMubGVhZlRleHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgYmFzaWNhbGx5IHRoZSBcIkFwcGx5IGFuY2hvcmluZ1wiIHBhcnQgb2YgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzIvdGV4dC5odG1sI1RleHRMYXlvdXRBbGdvcml0aG0uXG4gICAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgYXBwbHkgdGhlIGFuY2hvcmluZyBhcyBzb29uIGFzIGEgY2h1bmsgaXMgZmluaXNoZWQuIFRoaXMgc2F2ZXMgc29tZSBleHRyYSBsb29waW5nLlxuICAgICAgICAvLyBWZXJ0aWNhbCB0ZXh0IGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9IHRoaXMubGVhZlRleHRzW3RoaXMudGV4dENodW5rU3RhcnRdO1xuICAgICAgICBjb25zdCB0ZXh0QW5jaG9yID0gZmlyc3RFbGVtZW50LmdldFN0eWxlKCd0ZXh0LWFuY2hvcicpLmdldFN0cmluZygnc3RhcnQnKTtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBmYWxzZSAvLyB3ZSB0cmVhdCBSVEwgbGlrZSBMVFJcbiAgICAgICAgO1xuICAgICAgICBsZXQgc2hpZnQgPSAwO1xuICAgICAgICBpZiAodGV4dEFuY2hvciA9PT0gJ3N0YXJ0JyAmJiAhaXNSVEwgfHwgdGV4dEFuY2hvciA9PT0gJ2VuZCcgJiYgaXNSVEwpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1pblg7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dEFuY2hvciA9PT0gJ2VuZCcgJiYgIWlzUlRMIHx8IHRleHRBbmNob3IgPT09ICdzdGFydCcgJiYgaXNSVEwpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1heFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gKHRoaXMubWluWCArIHRoaXMubWF4WCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IHRoaXMudGV4dENodW5rU3RhcnQ7IGkgPCB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLmxlYWZUZXh0c1tpXS54ICs9IHNoaWZ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0IG5ldyBjaHVua1xuICAgICAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IHRoaXMubGVhZlRleHRzLmxlbmd0aDtcbiAgICB9XG4gICAgYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZShjdHgpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKT0+e1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRoaXMsIHRoaXMsIGkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBseUFuY2hvcmluZygpO1xuICAgIH1cbiAgICBhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaTEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baTFdO1xuICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgICAgICB0ZXh0UGFyZW50LmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvbmx5IGxlYWZzIGFyZSByZWxldmFudFxuICAgICAgICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzKGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRqdXN0Q2hpbGRDb29yZGluYXRlcyhjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5tZWFzdXJlVGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGNoaWxkLnNldENvbnRleHQoY3R4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgeEF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgICAgY29uc3QgeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3knKTtcbiAgICAgICAgY29uc3QgZHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeCcpO1xuICAgICAgICBjb25zdCBkeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2R5Jyk7XG4gICAgICAgIGNvbnN0IGN1c3RvbUZvbnQgPSBjaGlsZC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgIGNvbnN0IGlzUlRMID0gQm9vbGVhbihjdXN0b21Gb250ID09PSBudWxsIHx8IGN1c3RvbUZvbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1c3RvbUZvbnQuaXNSVEwpO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hpbGRyZW4gaW5oZXJpdCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50KHMpLiBQb3NpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0J3MgZmlyc3QgY2hpbGQuXG4gICAgICAgICAgICBpZiAoIXhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICB4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ3gnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICB5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ3knKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgZHhBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgnZHgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgZHlBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgnZHknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkdGggPSBjaGlsZC5tZWFzdXJlVGV4dChjdHgpO1xuICAgICAgICBpZiAoaXNSVEwpIHtcbiAgICAgICAgICAgIHRleHRQYXJlbnQueCAtPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgLy8gYW4gXCJ4XCIgYXR0cmlidXRlIG1hcmtzIHRoZSBzdGFydCBvZiBhIG5ldyBjaHVua1xuICAgICAgICAgICAgdGV4dFBhcmVudC5hcHBseUFuY2hvcmluZygpO1xuICAgICAgICAgICAgY2hpbGQueCA9IHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQueCArPSBkeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0UGFyZW50LnggKz0gZHhBdHRyLmdldFBpeGVscygneCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQueCA9IHRleHRQYXJlbnQueDtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0UGFyZW50LnggPSBjaGlsZC54O1xuICAgICAgICBpZiAoIWlzUlRMKSB7XG4gICAgICAgICAgICB0ZXh0UGFyZW50LnggKz0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLnkgPSB5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnkgKz0gZHlBdHRyLmdldFBpeGVscygneScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGR5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGV4dFBhcmVudC55ICs9IGR5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnkgPSB0ZXh0UGFyZW50Lnk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dFBhcmVudC55ID0gY2hpbGQueTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBjdXJyZW50IGNodW5rIGFuZCBpdCdzIGJvdW5kc1xuICAgICAgICB0ZXh0UGFyZW50LmxlYWZUZXh0cy5wdXNoKGNoaWxkKTtcbiAgICAgICAgdGV4dFBhcmVudC5taW5YID0gTWF0aC5taW4odGV4dFBhcmVudC5taW5YLCBjaGlsZC54LCBjaGlsZC54ICsgd2lkdGgpO1xuICAgICAgICB0ZXh0UGFyZW50Lm1heFggPSBNYXRoLm1heCh0ZXh0UGFyZW50Lm1heFgsIGNoaWxkLngsIGNoaWxkLnggKyB3aWR0aCk7XG4gICAgICAgIGNoaWxkLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkyKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2kyXTtcbiAgICAgICAgLy8gbm90IGEgdGV4dCBub2RlP1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLmdldEJvdW5kaW5nQm94ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCk7XG4gICAgICAgIGlmIChib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEJvdW5kaW5nQm94ID0gdGV4dFBhcmVudC5nZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkQm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICByZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaTMpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baTNdO1xuICAgICAgICBjaGlsZC5yZW5kZXIoY3R4KTtcbiAgICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSk9PntcbiAgICAgICAgICAgIHRleHRQYXJlbnQucmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtZWFzdXJlVGV4dChjdHgpIHtcbiAgICAgICAgY29uc3QgeyBtZWFzdXJlQ2FjaGUgIH0gPSB0aGlzO1xuICAgICAgICBpZiAofm1lYXN1cmVDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgICAgIGNvbnN0IG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgcmVuZGVyVGV4dCk7XG4gICAgICAgIHRoaXMubWVhc3VyZUNhY2hlID0gbWVhc3VyZTtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgfVxuICAgIG1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgdGFyZ2V0VGV4dCkge1xuICAgICAgICBpZiAoIXRhcmdldFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBhcmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGN1c3RvbUZvbnQgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICBpZiAoY3VzdG9tRm9udCkge1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY3VzdG9tRm9udC5pc1JUTCA/IHRhcmdldFRleHQuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IHRhcmdldFRleHQ7XG4gICAgICAgICAgICBjb25zdCBkeCA9IHRvTnVtYmVycyhwYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG1lYXN1cmUgPSAwO1xuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgICAgICAgICAgbWVhc3VyZSArPSAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAqIGZvbnRTaXplIC8gY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVhc3VyZSArPSBkeFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICBpZiAoIWN0eC5tZWFzdXJlVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFRleHQubGVuZ3RoICogMTA7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IG1lYXN1cmUgIH0gPSBjdHgubWVhc3VyZVRleHQodGFyZ2V0VGV4dCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgIH1cbiAgICAvKipcbiAgICogSW5oZXJpdHMgcG9zaXRpb25hbCBhdHRyaWJ1dGVzIGZyb20ge0BsaW5rIFRleHRFbGVtZW50fSBwYXJlbnQocykuIEF0dHJpYnV0ZXNcbiAgICogYXJlIG9ubHkgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgdG8gaXRzIGZpcnN0IGNoaWxkLlxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICogQHJldHVybnMgVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvciBudWxsLlxuICAgKi8gZ2V0SW5oZXJpdGVkQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlKGN1cnJlbnQgaW5zdGFuY2VvZiBUZXh0RWxlbWVudCAmJiBjdXJyZW50LmlzRmlyc3RDaGlsZCgpICYmIGN1cnJlbnQucGFyZW50KXtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEF0dHIgPSBjdXJyZW50LnBhcmVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICBpZiAocGFyZW50QXR0ci5oYXNWYWx1ZSh0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRBdHRyLmdldFN0cmluZygnMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBuZXcudGFyZ2V0ID09PSBUZXh0RWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLmxlYWZUZXh0cyA9IFtdO1xuICAgICAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5taW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMubWVhc3VyZUNhY2hlID0gLTE7XG4gICAgfVxufVxuXG5jbGFzcyBUU3BhbkVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgbmV3LnRhcmdldCA9PT0gVFNwYW5FbGVtZW50ID8gdHJ1ZSA6IGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAndHNwYW4nO1xuICAgICAgICAvLyBpZiB0aGlzIG5vZGUgaGFzIGNoaWxkcmVuLCB0aGVuIHRoZXkgb3duIHRoZSB0ZXh0XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCA/ICcnIDogdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgICB9XG59XG5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgVFNwYW5FbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd0ZXh0Tm9kZSc7XG4gICAgfVxufVxuXG5jbGFzcyBQYXRoUGFyc2VyIGV4dGVuZHMgU1ZHUGF0aERhdGEge1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmkgPSAtMTtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5hbmdsZXMgPSBbXTtcbiAgICB9XG4gICAgaXNFbmQoKSB7XG4gICAgICAgIGNvbnN0IHsgaSAsIGNvbW1hbmRzICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGkgPj0gY29tbWFuZHMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuY29tbWFuZHNbKyt0aGlzLmldO1xuICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IHRoaXMuY29tbWFuZDtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmQ7XG4gICAgfVxuICAgIGdldFBvaW50KCkge1xuICAgICAgICBsZXQgeFByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6ICd4JywgeVByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6ICd5JztcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQodGhpcy5jb21tYW5kW3hQcm9wXSwgdGhpcy5jb21tYW5kW3lQcm9wXSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VBYnNvbHV0ZShwb2ludCk7XG4gICAgfVxuICAgIGdldEFzQ29udHJvbFBvaW50KHhQcm9wLCB5UHJvcCkge1xuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICAgICAgdGhpcy5jb250cm9sID0gcG9pbnQ7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgZ2V0QXNDdXJyZW50UG9pbnQoeFByb3AsIHlQcm9wKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQb2ludCh4UHJvcCwgeVByb3ApO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBwb2ludDtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBnZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ29tbWFuZCA9IHRoaXMucHJldmlvdXNDb21tYW5kLnR5cGU7XG4gICAgICAgIGlmIChwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLkNVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuU01PT1RIX0NVUlZFX1RPICYmIHByZXZpb3VzQ29tbWFuZCAhPT0gU1ZHUGF0aERhdGEuUVVBRF9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlNNT09USF9RVUFEX1RPKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZmxlY3QgcG9pbnRcbiAgICAgICAgY29uc3QgeyBjdXJyZW50OiB7IHg6IGN4ICwgeTogY3kgIH0gLCBjb250cm9sOiB7IHg6IG94ICwgeTogb3kgIH0gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCgyICogY3ggLSBveCwgMiAqIGN5IC0gb3kpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIG1ha2VBYnNvbHV0ZShwb2ludCkge1xuICAgICAgICBpZiAodGhpcy5jb21tYW5kLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgcG9pbnQueCArPSB4O1xuICAgICAgICAgICAgcG9pbnQueSArPSB5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgYWRkTWFya2VyKHBvaW50LCBmcm9tLCBwcmlvclRvKSB7XG4gICAgICAgIGNvbnN0IHsgcG9pbnRzICwgYW5nbGVzICB9ID0gdGhpcztcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgYW5nbGUgaXNuJ3QgZmlsbGVkIGluIGJlY2F1c2Ugd2UgZGlkbid0IGhhdmUgdGhpcyBwb2ludCB5ZXQgLi4uXG4gICAgICAgIGlmIChwcmlvclRvICYmIGFuZ2xlcy5sZW5ndGggPiAwICYmICFhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5hbmdsZVRvKHByaW9yVG8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkTWFya2VyQW5nbGUocG9pbnQsIGZyb20gPyBmcm9tLmFuZ2xlVG8ocG9pbnQpIDogbnVsbCk7XG4gICAgfVxuICAgIGFkZE1hcmtlckFuZ2xlKHBvaW50LCBhbmdsZSkge1xuICAgICAgICB0aGlzLnBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgdGhpcy5hbmdsZXMucHVzaChhbmdsZSk7XG4gICAgfVxuICAgIGdldE1hcmtlclBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICAgIH1cbiAgICBnZXRNYXJrZXJBbmdsZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgYW5nbGVzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gYW5nbGVzLmxlbmd0aDtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgIGlmICghYW5nbGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBqID0gaSArIDE7IGogPCBsZW47IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZXNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlc1tpXSA9IGFuZ2xlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmdsZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGgpe1xuICAgICAgICBzdXBlcihwYXRoLy8gRml4IHNwYWNlcyBhZnRlciBzaWducy5cbiAgICAgICAgLnJlcGxhY2UoLyhbK1xcLS5dKVxccysvZ20sICckMScpLy8gUmVtb3ZlIGludmFsaWQgcGFydC5cbiAgICAgICAgLnJlcGxhY2UoL1teTW1aekxsSGhWdkNjU3NRcVR0QWFlXFxkXFxzLiwrLV0uKi9nLCAnJykpO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgICAgIHRoaXMuaSA9IC0xO1xuICAgICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgIHRoaXMuYW5nbGVzID0gW107XG4gICAgfVxufVxuXG5jbGFzcyBQYXRoRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgICAgcGF0aFBhcnNlci5yZXNldCgpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoIXBhdGhQYXJzZXIuaXNFbmQoKSl7XG4gICAgICAgICAgICBzd2l0Y2gocGF0aFBhcnNlci5uZXh0KCkudHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aE0oY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhMKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoSChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlZFUlRfTElORV9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoVihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhDKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhTKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoUShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhUKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhBKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRoWihjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBnZXRCb3VuZGluZ0JveChfY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgoKTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcG9pbnRzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcbiAgICAgICAgY29uc3QgYW5nbGVzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJBbmdsZXMoKTtcbiAgICAgICAgY29uc3QgbWFya2VycyA9IHBvaW50cy5tYXAoKHBvaW50LCBpKT0+W1xuICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgICAgIGFuZ2xlc1tpXVxuICAgICAgICAgICAgXVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICAgIHRoaXMucGF0aChjdHgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50LnNjcmVlbi5tb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcbiAgICAgICAgY29uc3QgZmlsbFJ1bGVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmaWxsLXJ1bGUnKTtcbiAgICAgICAgaWYgKGN0eC5maWxsU3R5bGUgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoZmlsbFJ1bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCdpbmhlcml0JykgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCd2ZWN0b3ItZWZmZWN0JykuZ2V0U3RyaW5nKCkgPT09ICdub24tc2NhbGluZy1zdHJva2UnKSB7XG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuICAgICAgICBpZiAobWFya2Vycykge1xuICAgICAgICAgICAgY29uc3QgbWFya2Vyc0xhc3RJbmRleCA9IG1hcmtlcnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlclN0YXJ0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLXN0YXJ0Jyk7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJNaWRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItbWlkJyk7XG4gICAgICAgICAgICBjb25zdCBtYXJrZXJFbmRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItZW5kJyk7XG4gICAgICAgICAgICBpZiAobWFya2VyU3RhcnRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJTdGFydFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BvaW50LCBhbmdsZV0gPSBtYXJrZXJzWzBdO1xuICAgICAgICAgICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcmtlck1pZFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlck1pZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IG1hcmtlcnNMYXN0SW5kZXg7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwb2ludCwgYW5nbGVdID0gbWFya2Vyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLnJlbmRlcihjdHgsIHBvaW50LCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcmtlckVuZFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IG1hcmtlckVuZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BvaW50LCBhbmdsZV0gPSBtYXJrZXJzW21hcmtlcnNMYXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgIG1hcmtlci5yZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoTShwYXRoUGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICBwYXRoUGFyc2VyLnN0YXJ0ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aE0oY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcik7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBwb2ludDtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aEwocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBwb2ludFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXRoTChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IHsgcGF0aFBhcnNlciAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAsIHBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlcik7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBwb2ludDtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aEgocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBjb21tYW5kICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgUG9pbnQoKGNvbW1hbmQucmVsYXRpdmUgPyBjdXJyZW50LnggOiAwKSArIGNvbW1hbmQueCwgY3VycmVudC55KTtcbiAgICAgICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgcG9pbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aEgoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBwb2ludCAgfSA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpO1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gcG9pbnQ7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhdGhWKHBhdGhQYXJzZXIpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgY29tbWFuZCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KGN1cnJlbnQueCwgKGNvbW1hbmQucmVsYXRpdmUgPyBjdXJyZW50LnkgOiAwKSArIGNvbW1hbmQueSk7XG4gICAgICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBvaW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhWKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgcG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKTtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHBvaW50O1xuICAgICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoQyhwYXRoUGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aFBhcnNlci5nZXRQb2ludCgneDEnLCAneTEnKTtcbiAgICAgICAgY29uc3QgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgY29udHJvbFBvaW50LFxuICAgICAgICAgICAgY3VycmVudFBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhDKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgcG9pbnQgLCBjb250cm9sUG9pbnQgLCBjdXJyZW50UG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoQyhwYXRoUGFyc2VyKTtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIHBvaW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoUyhwYXRoUGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcGF0aFBhcnNlci5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKTtcbiAgICAgICAgY29uc3QgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgY29udHJvbFBvaW50LFxuICAgICAgICAgICAgY3VycmVudFBvaW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIHBhdGhTKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoUGFyc2VyICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjdXJyZW50ICwgcG9pbnQgLCBjb250cm9sUG9pbnQgLCBjdXJyZW50UG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKTtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIHBvaW50KTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoUShwYXRoUGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjb250cm9sUG9pbnQsXG4gICAgICAgICAgICBjdXJyZW50UG9pbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aFEoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBjb250cm9sUG9pbnQgLCBjdXJyZW50UG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoUShwYXRoUGFyc2VyKTtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZFF1YWRyYXRpY0N1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aFQocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgIH0gPSBwYXRoUGFyc2VyO1xuICAgICAgICBjb25zdCBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgICAgICBwYXRoUGFyc2VyLmNvbnRyb2wgPSBjb250cm9sUG9pbnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjb250cm9sUG9pbnQsXG4gICAgICAgICAgICBjdXJyZW50UG9pbnRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aFQoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBjb250cm9sUG9pbnQgLCBjdXJyZW50UG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoVChwYXRoUGFyc2VyKTtcbiAgICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgICAgIGJvdW5kaW5nQm94LmFkZFF1YWRyYXRpY0N1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGF0aEEocGF0aFBhcnNlcikge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgLCBjb21tYW5kICB9ID0gcGF0aFBhcnNlcjtcbiAgICAgICAgbGV0IHsgclggLCByWSAsIHhSb3QgLCBsQXJjRmxhZyAsIHN3ZWVwRmxhZyAgfSA9IGNvbW1hbmQ7XG4gICAgICAgIGNvbnN0IHhBeGlzUm90YXRpb24gPSB4Um90ICogKE1hdGguUEkgLyAxODApO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICAgIC8vIENvbnZlcnNpb24gZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldGVyaXphdGlvblxuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICAgICAgLy8geDEnLCB5MSdcbiAgICAgICAgY29uc3QgY3VycnAgPSBuZXcgUG9pbnQoTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMiArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIsIC1NYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIChjdXJyZW50LnggLSBjdXJyZW50UG9pbnQueCkgLyAyICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC55IC0gY3VycmVudFBvaW50LnkpIC8gMik7XG4gICAgICAgIC8vIGFkanVzdCByYWRpaVxuICAgICAgICBjb25zdCBsID0gTWF0aC5wb3coY3VycnAueCwgMikgLyBNYXRoLnBvdyhyWCwgMikgKyBNYXRoLnBvdyhjdXJycC55LCAyKSAvIE1hdGgucG93KHJZLCAyKTtcbiAgICAgICAgaWYgKGwgPiAxKSB7XG4gICAgICAgICAgICByWCAqPSBNYXRoLnNxcnQobCk7XG4gICAgICAgICAgICByWSAqPSBNYXRoLnNxcnQobCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3gnLCBjeSdcbiAgICAgICAgbGV0IHMgPSAobEFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBNYXRoLnNxcnQoKE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KHJZLCAyKSAtIE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KGN1cnJwLnksIDIpIC0gTWF0aC5wb3coclksIDIpICogTWF0aC5wb3coY3VycnAueCwgMikpIC8gKE1hdGgucG93KHJYLCAyKSAqIE1hdGgucG93KGN1cnJwLnksIDIpICsgTWF0aC5wb3coclksIDIpICogTWF0aC5wb3coY3VycnAueCwgMikpKTtcbiAgICAgICAgaWYgKGlzTmFOKHMpKSB7XG4gICAgICAgICAgICBzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcHAgPSBuZXcgUG9pbnQocyAqIHJYICogY3VycnAueSAvIHJZLCBzICogLXJZICogY3VycnAueCAvIHJYKTtcbiAgICAgICAgLy8gY3gsIGN5XG4gICAgICAgIGNvbnN0IGNlbnRwID0gbmV3IFBvaW50KChjdXJyZW50LnggKyBjdXJyZW50UG9pbnQueCkgLyAyICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnksIChjdXJyZW50LnkgKyBjdXJyZW50UG9pbnQueSkgLyAyICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnkpO1xuICAgICAgICAvLyBpbml0aWFsIGFuZ2xlXG4gICAgICAgIGNvbnN0IGExID0gdmVjdG9yc0FuZ2xlKFtcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAwXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIChjdXJycC54IC0gY3BwLngpIC8gclgsXG4gICAgICAgICAgICAoY3VycnAueSAtIGNwcC55KSAvIHJZXG4gICAgICAgIF0pIC8vIM64MVxuICAgICAgICA7XG4gICAgICAgIC8vIGFuZ2xlIGRlbHRhXG4gICAgICAgIGNvbnN0IHUgPSBbXG4gICAgICAgICAgICAoY3VycnAueCAtIGNwcC54KSAvIHJYLFxuICAgICAgICAgICAgKGN1cnJwLnkgLSBjcHAueSkgLyByWVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCB2ID0gW1xuICAgICAgICAgICAgKC1jdXJycC54IC0gY3BwLngpIC8gclgsXG4gICAgICAgICAgICAoLWN1cnJwLnkgLSBjcHAueSkgLyByWVxuICAgICAgICBdO1xuICAgICAgICBsZXQgYWQgPSB2ZWN0b3JzQW5nbGUodSwgdikgLy8gzpTOuFxuICAgICAgICA7XG4gICAgICAgIGlmICh2ZWN0b3JzUmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgICAgIGFkID0gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgICAgICAgIGFkID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFBvaW50LFxuICAgICAgICAgICAgclgsXG4gICAgICAgICAgICByWSxcbiAgICAgICAgICAgIHN3ZWVwRmxhZyxcbiAgICAgICAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICAgICAgICBjZW50cCxcbiAgICAgICAgICAgIGExLFxuICAgICAgICAgICAgYWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGF0aEEoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRQb2ludCAsIHJYICwgclkgLCBzd2VlcEZsYWcgLCB4QXhpc1JvdGF0aW9uICwgY2VudHAgLCBhMSAsIGFkICB9ID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlcik7XG4gICAgICAgIC8vIGZvciBtYXJrZXJzXG4gICAgICAgIGNvbnN0IGRpciA9IDEgLSBzd2VlcEZsYWcgPyAxIDogLTE7XG4gICAgICAgIGNvbnN0IGFoID0gYTEgKyBkaXIgKiAoYWQgLyAyKTtcbiAgICAgICAgY29uc3QgaGFsZldheSA9IG5ldyBQb2ludChjZW50cC54ICsgclggKiBNYXRoLmNvcyhhaCksIGNlbnRwLnkgKyByWSAqIE1hdGguc2luKGFoKSk7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoaGFsZldheSwgYWggLSBkaXIgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoY3VycmVudFBvaW50LCBhaCAtIGRpciAqIE1hdGguUEkpO1xuICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpIC8vIFRPRE86IHRoaXMgaXMgdG9vIG5haXZlLCBtYWtlIGl0IGJldHRlclxuICAgICAgICA7XG4gICAgICAgIGlmIChjdHggJiYgIWlzTmFOKGExKSAmJiAhaXNOYU4oYWQpKSB7XG4gICAgICAgICAgICBjb25zdCByID0gclggPiByWSA/IHJYIDogclk7XG4gICAgICAgICAgICBjb25zdCBzeCA9IHJYID4gclkgPyAxIDogclggLyByWTtcbiAgICAgICAgICAgIGNvbnN0IHN5ID0gclggPiByWSA/IHJZIC8gclggOiAxO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50cC54LCBjZW50cC55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoeEF4aXNSb3RhdGlvbik7XG4gICAgICAgICAgICBjdHguc2NhbGUoc3gsIHN5KTtcbiAgICAgICAgICAgIGN0eC5hcmMoMCwgMCwgciwgYTEsIGExICsgYWQsIEJvb2xlYW4oMSAtIHN3ZWVwRmxhZykpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzeCwgMSAvIHN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2VudHAueCwgLWNlbnRwLnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXRoWihwYXRoUGFyc2VyKSB7XG4gICAgICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBhdGhQYXJzZXIuc3RhcnQ7XG4gICAgfVxuICAgIHBhdGhaKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgUGF0aEVsZW1lbnQucGF0aFoodGhpcy5wYXRoUGFyc2VyKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgLy8gb25seSBjbG9zZSBwYXRoIGlmIGl0IGlzIG5vdCBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgICAgICAgIGlmIChib3VuZGluZ0JveC54MSAhPT0gYm91bmRpbmdCb3gueDIgJiYgYm91bmRpbmdCb3gueTEgIT09IGJvdW5kaW5nQm94LnkyKSB7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncGF0aCc7XG4gICAgICAgIHRoaXMucGF0aFBhcnNlciA9IG5ldyBQYXRoUGFyc2VyKHRoaXMuZ2V0QXR0cmlidXRlKCdkJykuZ2V0U3RyaW5nKCkpO1xuICAgIH1cbn1cblxuY2xhc3MgU1ZHRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gICAgc2V0Q29udGV4dChjdHgpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc2NyZWVuICwgd2luZG93ICB9ID0gZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICAgIHNjcmVlbi5zZXREZWZhdWx0cyhjdHgpO1xuICAgICAgICBpZiAoJ3N0eWxlJyBpbiBjYW52YXMgJiYgdHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3R4LmZvbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQnKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShjdHguZm9udCkuZm9udFNpemUpO1xuICAgICAgICAgICAgaWYgKGZvbnRTaXplUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucm9vdEVtU2l6ZSA9IGZvbnRTaXplUHJvcC5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5lbVNpemUgPSBkb2N1bWVudC5yb290RW1TaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgdmlldyBwb3J0XG4gICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneCcsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHdpZHRoICwgaGVpZ2h0ICB9ID0gc2NyZWVuLnZpZXdQb3J0O1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHlsZSgnY29sb3InLCB0cnVlKS5zZXRWYWx1ZSgnYmxhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZYQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJyk7XG4gICAgICAgIGNvbnN0IHJlZllBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlknKTtcbiAgICAgICAgY29uc3Qgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgICBjb25zdCB2aWV3Qm94ID0gdmlld0JveEF0dHIuaGFzVmFsdWUoKSA/IHRvTnVtYmVycyh2aWV3Qm94QXR0ci5nZXRTdHJpbmcoKSkgOiBudWxsO1xuICAgICAgICBjb25zdCBjbGlwID0gIXRoaXMucm9vdCAmJiB0aGlzLmdldFN0eWxlKCdvdmVyZmxvdycpLmdldFZhbHVlKCdoaWRkZW4nKSAhPT0gJ3Zpc2libGUnO1xuICAgICAgICBsZXQgbWluWCA9IDA7XG4gICAgICAgIGxldCBtaW5ZID0gMDtcbiAgICAgICAgbGV0IGNsaXBYID0gMDtcbiAgICAgICAgbGV0IGNsaXBZID0gMDtcbiAgICAgICAgaWYgKHZpZXdCb3gpIHtcbiAgICAgICAgICAgIG1pblggPSB2aWV3Qm94WzBdO1xuICAgICAgICAgICAgbWluWSA9IHZpZXdCb3hbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcmtlcicpIHtcbiAgICAgICAgICAgICAgICBjbGlwWCA9IG1pblg7XG4gICAgICAgICAgICAgICAgY2xpcFkgPSBtaW5ZO1xuICAgICAgICAgICAgICAgIG1pblggPSAwO1xuICAgICAgICAgICAgICAgIG1pblkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlIG9mIHRyYW5zZm9ybS1vcmlnaW4gaXMgY2VudGVyIG9ubHkgZm9yIHJvb3QgU1ZHIGVsZW1lbnRzXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdHJhbnNmb3JtLW9yaWdpblxuICAgICAgICBpZiAodGhpcy5ub2RlIC8vIGlzIG5vdCB0ZW1wb3JhcnkgU1ZHRWxlbWVudFxuICAgICAgICAgJiYgKCF0aGlzLnBhcmVudCB8fCAoKHJlZiA9IHRoaXMubm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCByZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZi5ub2RlTmFtZSkgPT09ICdmb3JlaWduT2JqZWN0JykgJiYgdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIHRydWUsIHRydWUpLnNldFZhbHVlKCc1MCUgNTAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2V0Q29udGV4dChjdHgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5JykpO1xuICAgICAgICBpZiAodmlld0JveCkge1xuICAgICAgICAgICAgd2lkdGggPSB2aWV3Qm94WzJdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdmlld0JveFszXTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5zZXRWaWV3Qm94KHtcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLmdldFN0cmluZygpLFxuICAgICAgICAgICAgd2lkdGg6IHNjcmVlbi52aWV3UG9ydC53aWR0aCxcbiAgICAgICAgICAgIGRlc2lyZWRXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNjcmVlbi52aWV3UG9ydC5oZWlnaHQsXG4gICAgICAgICAgICBkZXNpcmVkSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICBtaW5YLFxuICAgICAgICAgICAgbWluWSxcbiAgICAgICAgICAgIHJlZlg6IHJlZlhBdHRyLmdldFZhbHVlKCksXG4gICAgICAgICAgICByZWZZOiByZWZZQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgICAgICAgY2xpcCxcbiAgICAgICAgICAgIGNsaXBYLFxuICAgICAgICAgICAgY2xpcFlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgICAgICBzY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgICAgICAgc2NyZWVuLnZpZXdQb3J0LnNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJDb250ZXh0KGN0eCkge1xuICAgICAgICBzdXBlci5jbGVhckNvbnRleHQoY3R4KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5zY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHRcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cbiAgICovIHJlc2l6ZSh3aWR0aCkge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB3aWR0aCwgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IHdpZHRoQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpO1xuICAgICAgICBjb25zdCBoZWlnaHRBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpO1xuICAgICAgICBjb25zdCB2aWV3Qm94QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICAgIGNvbnN0IHN0eWxlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBjb25zdCBvcmlnaW5XaWR0aCA9IHdpZHRoQXR0ci5nZXROdW1iZXIoMCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbkhlaWdodCA9IGhlaWdodEF0dHIuZ2V0TnVtYmVyKDApO1xuICAgICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdHJ1ZSkuc2V0VmFsdWUocHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5nZXRTdHJpbmcoKS5yZXBsYWNlKC9eXFxzKihcXFMuKlxcUylcXHMqJC8sICckMScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGhBdHRyLnNldFZhbHVlKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0QXR0ci5zZXRWYWx1ZShoZWlnaHQpO1xuICAgICAgICBpZiAoIXZpZXdCb3hBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHZpZXdCb3hBdHRyLnNldFZhbHVlKFwiMCAwIFwiLmNvbmNhdChvcmlnaW5XaWR0aCB8fCB3aWR0aCwgXCIgXCIpLmNvbmNhdChvcmlnaW5IZWlnaHQgfHwgaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgd2lkdGhTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGhlaWdodFN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3ZnJztcbiAgICAgICAgdGhpcy5yb290ID0gZmFsc2U7XG4gICAgfVxufVxuXG5jbGFzcyBSZWN0RWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCBmYWxzZSwgdHJ1ZSkuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgcnhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J4Jyk7XG4gICAgICAgIGNvbnN0IHJ5QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpO1xuICAgICAgICBsZXQgcnggPSByeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGxldCByeSA9IHJ5QXR0ci5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgaWYgKHJ4QXR0ci5oYXNWYWx1ZSgpICYmICFyeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcnkgPSByeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnlBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICByeCA9IHJ5O1xuICAgICAgICB9XG4gICAgICAgIHJ4ID0gTWF0aC5taW4ocngsIHdpZHRoIC8gMik7XG4gICAgICAgIHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIpO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCkgLy8gYWx3YXlzIHN0YXJ0IHRoZSBwYXRoIHNvIHdlIGRvbid0IGZpbGwgcHJpb3IgcGF0aHNcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPiAwICYmIHdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGggLSByeCArIEtBUFBBICogcngsIHksIHggKyB3aWR0aCwgeSArIHJ5IC0gS0FQUEEgKiByeSwgeCArIHdpZHRoLCB5ICsgcnkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyByeCAtIEtBUFBBICogcngsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyByeCAtIEtBUFBBICogcngsIHksIHggKyByeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3JlY3QnO1xuICAgIH1cbn1cblxuY2xhc3MgQ2lyY2xlRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCBjeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCByID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXRQaXhlbHMoKTtcbiAgICAgICAgaWYgKGN0eCAmJiByID4gMCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHIsIGN5IC0gciwgY3ggKyByLCBjeSArIHIpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnY2lyY2xlJztcbiAgICB9XG59XG5cbmNsYXNzIEVsbGlwc2VFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IEtBUFBBID0gNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKTtcbiAgICAgICAgY29uc3QgcnggPSB0aGlzLmdldEF0dHJpYnV0ZSgncngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgcnkgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgY29uc3QgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgaWYgKGN0eCAmJiByeCA+IDAgJiYgcnkgPiAwKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGN4ICsgcngsIGN5KTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggKyBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCwgY3kgKyByeSk7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCAtIEtBUFBBICogcngsIGN5ICsgcnksIGN4IC0gcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggLSByeCwgY3kpO1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCAtIEtBUFBBICogcngsIGN5IC0gcnksIGN4LCBjeSAtIHJ5KTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgS0FQUEEgKiByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCArIHJ4LCBjeSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcbiAgICB9XG4gICAgZ2V0TWFya2VycygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2VsbGlwc2UnO1xuICAgIH1cbn1cblxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXRQaXhlbHMoJ3knKSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldFBpeGVscygneScpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCBbeyB4OiB4MCAsIHk6IHkwICB9LCB7IHg6IHgxICwgeTogeTEgIH1dID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4MSwgeTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJzKCkge1xuICAgICAgICBjb25zdCBbcDAsIHAxXSA9IHRoaXMuZ2V0UG9pbnRzKCk7XG4gICAgICAgIGNvbnN0IGEgPSBwMC5hbmdsZVRvKHAxKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBwMCxcbiAgICAgICAgICAgICAgICBhXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHAxLFxuICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgIF1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbGluZSc7XG4gICAgfVxufVxuXG5jbGFzcyBQb2x5bGluZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgeyBwb2ludHMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBbeyB4OiB4MCAsIHk6IHkwICB9XSA9IHBvaW50cztcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goeDAsIHkwKTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50cy5mb3JFYWNoKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHggLCB5ICB9ID0gcGFyYW07XG4gICAgICAgICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBnZXRNYXJrZXJzKCkge1xuICAgICAgICBjb25zdCB7IHBvaW50cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBtYXJrZXJzID0gW107XG4gICAgICAgIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaSk9PntcbiAgICAgICAgICAgIGlmIChpID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrZXJzLnB1c2goW1xuICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgICAgIHBvaW50LmFuZ2xlVG8ocG9pbnRzW2kgKyAxXSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbWFya2Vycy5wdXNoKFtcbiAgICAgICAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXVsxXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncG9seWxpbmUnO1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICB0aGlzLnBvaW50cyA9IFBvaW50LnBhcnNlUGF0aCh0aGlzLmdldEF0dHJpYnV0ZSgncG9pbnRzJykuZ2V0U3RyaW5nKCkpO1xuICAgIH1cbn1cblxuY2xhc3MgUG9seWdvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUVsZW1lbnQge1xuICAgIHBhdGgoY3R4KSB7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gc3VwZXIucGF0aChjdHgpO1xuICAgICAgICBjb25zdCBbeyB4ICwgeSAgfV0gPSB0aGlzLnBvaW50cztcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3BvbHlnb24nO1xuICAgIH1cbn1cblxuY2xhc3MgUGF0dGVybkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjcmVhdGVQYXR0ZXJuKGN0eCwgXywgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcsIHRydWUpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knLCB0cnVlKTtcbiAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG4gICAgICAgIGNvbnN0IHBhdHRlcm5TdmcgPSBuZXcgU1ZHRWxlbWVudCh0aGlzLmRvY3VtZW50LCBudWxsKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpLmdldFZhbHVlKCkpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgcGF0dGVybkNhbnZhcyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb25zdCB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGNvbnN0IHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcbiAgICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkgJiYgeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcGF0dGVybkN0eC50cmFuc2xhdGUoeEF0dHIuZ2V0UGl4ZWxzKCd4JywgdHJ1ZSksIHlBdHRyLmdldFBpeGVscygneScsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXNbJ2ZpbGwtb3BhY2l0eSddID0gcGFyZW50T3BhY2l0eVByb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMuc3R5bGVzLCAnZmlsbC1vcGFjaXR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVuZGVyIDN4MyBncmlkIHNvIHdoZW4gd2UgdHJhbnNmb3JtIHRoZXJlJ3Mgbm8gd2hpdGUgc3BhY2Ugb24gZWRnZXNcbiAgICAgICAgZm9yKGxldCB4ID0gLTE7IHggPD0gMTsgeCsrKXtcbiAgICAgICAgICAgIGZvcihsZXQgeSA9IC0xOyB5IDw9IDE7IHkrKyl7XG4gICAgICAgICAgICAgICAgcGF0dGVybkN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3gnLCB4ICogcGF0dGVybkNhbnZhcy53aWR0aCk7XG4gICAgICAgICAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3knLCB5ICogcGF0dGVybkNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5TdmcucmVuZGVyKHBhdHRlcm5DdHgpO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5DdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuQ2FudmFzLCAncmVwZWF0Jyk7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbiAgICB9XG59XG5cbmNsYXNzIE1hcmtlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICByZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpIHtcbiAgICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBwb2ludDtcbiAgICAgICAgY29uc3Qgb3JpZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudCcpLmdldFN0cmluZygnYXV0bycpO1xuICAgICAgICBjb25zdCBtYXJrZXJVbml0cyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJVbml0cycpLmdldFN0cmluZygnc3Ryb2tlV2lkdGgnKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgICAgICAgIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcbiAgICAgICAgY29uc3QgbWFya2VyU3ZnID0gbmV3IFNWR0VsZW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIG1hcmtlclN2Zy50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd2aWV3Qm94JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZYJykuZ2V0VmFsdWUoKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnJlZlkgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3JlZlknLCB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWScpLmdldFZhbHVlKCkpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnd2lkdGgnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyV2lkdGgnKS5nZXRWYWx1ZSgpKTtcbiAgICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdoZWlnaHQnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VySGVpZ2h0JykuZ2V0VmFsdWUoKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLm92ZXJmbG93ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdvdmVyZmxvdycsIHRoaXMuZ2V0QXR0cmlidXRlKCdvdmVyZmxvdycpLmdldFZhbHVlKCkpO1xuICAgICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5maWxsID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRDb2xvcignYmxhY2snKSk7XG4gICAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnN0cm9rZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnc3Ryb2tlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZScpLmdldFZhbHVlKCdub25lJykpO1xuICAgICAgICBtYXJrZXJTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBtYXJrZXJTdmcucmVuZGVyKGN0eCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBjdHgubGluZVdpZHRoLCAxIC8gY3R4LmxpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXJrZXInO1xuICAgIH1cbn1cblxuY2xhc3MgRGVmc0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgLy8gTk9PUFxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdkZWZzJztcbiAgICB9XG59XG5cbmNsYXNzIEdFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3goKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdnJztcbiAgICB9XG59XG5cbmNsYXNzIEdyYWRpZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGdldEdyYWRpZW50VW5pdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpLmdldFN0cmluZygnb2JqZWN0Qm91bmRpbmdCb3gnKTtcbiAgICB9XG4gICAgY3JlYXRlR3JhZGllbnQoY3R4LCBlbGVtZW50LCBwYXJlbnRPcGFjaXR5UHJvcCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBsZXQgc3RvcHNDb250YWluZXIgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgc3RvcHNDb250YWluZXIgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3BzICB9ID0gc3RvcHNDb250YWluZXI7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gdGhpcy5nZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpO1xuICAgICAgICBpZiAoIWdyYWRpZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXS5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHMuZm9yRWFjaCgoc3RvcCk9PntcbiAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLm9mZnNldCwgdGhpcy5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wLmNvbG9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgLy8gcmVuZGVyIGFzIHRyYW5zZm9ybWVkIHBhdHRlcm4gb24gdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IE1BWF9WSVJUVUFMX1BJWEVMUyAgfSA9IFNjcmVlbjtcbiAgICAgICAgICAgIGNvbnN0IHsgdmlld1BvcnQgIH0gPSBkb2N1bWVudC5zY3JlZW47XG4gICAgICAgICAgICBjb25zdCByb290VmlldyA9IHZpZXdQb3J0LmdldFJvb3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBuZXcgUmVjdEVsZW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgLU1BWF9WSVJUVUFMX1BJWEVMUyAvIDMpO1xuICAgICAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd5JywgLU1BWF9WSVJUVUFMX1BJWEVMUyAvIDMpO1xuICAgICAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCBNQVhfVklSVFVBTF9QSVhFTFMpO1xuICAgICAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIE1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICAgICAgICBjb25zdCBncm91cCA9IG5ldyBHRWxlbWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICBncm91cC5hdHRyaWJ1dGVzLnRyYW5zZm9ybSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3RyYW5zZm9ybScsIHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW4gPSBbXG4gICAgICAgICAgICAgICAgcmVjdFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5TdmcgPSBuZXcgU1ZHRWxlbWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAwKTtcbiAgICAgICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIDApO1xuICAgICAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XG4gICAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgICAgICAgIHBhdHRlcm5TdmcuY2hpbGRyZW4gPSBbXG4gICAgICAgICAgICAgICAgZ3JvdXBcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHJvb3RWaWV3LndpZHRoLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm5DYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgICAgICBwYXR0ZXJuU3ZnLnJlbmRlcihwYXR0ZXJuQ3R4KTtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuQ3R4LmNyZWF0ZVBhdHRlcm4ocGF0dGVybkNhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gICAgaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LmZvckVhY2goKGF0dHJpYnV0ZVRvSW5oZXJpdCk9PntcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpICYmIHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQsIHRydWUpLnNldFZhbHVlKHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgY29sb3IpIHtcbiAgICAgICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yUHJvcCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnY29sb3InLCBjb2xvcik7XG4gICAgICAgICAgICByZXR1cm4gY29sb3JQcm9wLmFkZE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3ApLmdldENvbG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0ID0gW1xuICAgICAgICAgICAgJ2dyYWRpZW50VW5pdHMnXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICAgICAgY29uc3QgeyBzdG9wcyAsIGNoaWxkcmVuICB9ID0gdGhpcztcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ3N0b3AnKSB7XG4gICAgICAgICAgICAgICAgc3RvcHMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgTGluZWFyR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgR3JhZGllbnRFbGVtZW50IHtcbiAgICBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpIDogbnVsbDtcbiAgICAgICAgaWYgKGlzQm91bmRpbmdCb3hVbml0cyAmJiAhYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneTEnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4MicsIHRydWUpLnNldFZhbHVlKDEpO1xuICAgICAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeDEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpO1xuICAgICAgICBjb25zdCB5MSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCB4MiA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdsaW5lYXJHcmFkaWVudCc7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd4MScsICd5MScsICd4MicsICd5MicpO1xuICAgIH1cbn1cblxuY2xhc3MgUmFkaWFsR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgR3JhZGllbnRFbGVtZW50IHtcbiAgICBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgICAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3knLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgncicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdyJywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN4ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgY3kgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgbGV0IGZ4ID0gY3g7XG4gICAgICAgIGxldCBmeSA9IGN5O1xuICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgZnggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBmeSA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmdldFBpeGVscygneScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyAoYm91bmRpbmdCb3gud2lkdGggKyBib3VuZGluZ0JveC5oZWlnaHQpIC8gMiAqIHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldFBpeGVscygpO1xuICAgICAgICBjb25zdCBmciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdmcicpLmdldFBpeGVscygpO1xuICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgZnIsIGN4LCBjeSwgcik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncmFkaWFsR3JhZGllbnQnO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnY3gnLCAnY3knLCAncicsICdmeCcsICdmeScsICdmcicpO1xuICAgIH1cbn1cblxuY2xhc3MgU3RvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N0b3AnO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykuZ2V0TnVtYmVyKCkpKTtcbiAgICAgICAgY29uc3Qgc3RvcE9wYWNpdHkgPSB0aGlzLmdldFN0eWxlKCdzdG9wLW9wYWNpdHknKTtcbiAgICAgICAgbGV0IHN0b3BDb2xvciA9IHRoaXMuZ2V0U3R5bGUoJ3N0b3AtY29sb3InLCB0cnVlKTtcbiAgICAgICAgaWYgKHN0b3BDb2xvci5nZXRTdHJpbmcoKSA9PT0gJycpIHtcbiAgICAgICAgICAgIHN0b3BDb2xvci5zZXRWYWx1ZSgnIzAwMCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wT3BhY2l0eS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBzdG9wQ29sb3IgPSBzdG9wQ29sb3IuYWRkT3BhY2l0eShzdG9wT3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY29sb3IgPSBzdG9wQ29sb3IuZ2V0Q29sb3IoKTtcbiAgICB9XG59XG5cbmNsYXNzIEFuaW1hdGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgZ2V0UHJvcGVydHkoKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlVHlwZScpLmdldFN0cmluZygpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZU5hbWUnKS5nZXRTdHJpbmcoKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZVR5cGUgPT09ICdDU1MnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgY2FsY1ZhbHVlKCkge1xuICAgICAgICBjb25zdCB7IGluaXRpYWxVbml0cyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3Jlc3MgLCBmcm9tICwgdG8gIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7XG4gICAgICAgIC8vIHR3ZWVuIHZhbHVlIGxpbmVhcmx5XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGZyb20uZ2V0TnVtYmVyKCkgKyAodG8uZ2V0TnVtYmVyKCkgLSBmcm9tLmdldE51bWJlcigpKSAqIHByb2dyZXNzO1xuICAgICAgICBpZiAoaW5pdGlhbFVuaXRzID09PSAnJScpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlICo9IDEwMCAvLyBudW1WYWx1ZSgpIHJldHVybnMgMC0xIHdoZXJlYXMgcHJvcGVydGllcyBhcmUgMC0xMDBcbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobmV3VmFsdWUpLmNvbmNhdChpbml0aWFsVW5pdHMpO1xuICAgIH1cbiAgICB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnQgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBwcm9wID0gdGhpcy5nZXRQcm9wZXJ0eSgpO1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxVbml0cyA9IHByb3AuZ2V0VW5pdHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBlbmQgdGltZVxuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZmlsbCcpLmdldFN0cmluZygncmVtb3ZlJyk7XG4gICAgICAgICAgICAvLyBsb29wIGZvciBpbmRlZmluaXRlbHkgcmVwZWF0aW5nIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgncmVwZWF0Q291bnQnKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXREdXInKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdmcmVlemUnICYmICF0aGlzLmZyb3plbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9IHByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsID09PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcC5zZXRWYWx1ZShwYXJlbnQuYW5pbWF0aW9uRnJvemVuID8gcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlIDogdGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR1cmF0aW9uICs9IGRlbHRhO1xuICAgICAgICAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBiZWdpbiB0aW1lXG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmJlZ2luIDwgdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gdGhpcy5jYWxjVmFsdWUoKSAvLyB0d2VlblxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgY29uc3QgdHlwZUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICAgICAgaWYgKHR5cGVBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgdHJhbnNmb3JtLCBldGMuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVBdHRyLmdldFN0cmluZygpO1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gXCJcIi5jb25jYXQodHlwZSwgXCIoXCIpLmNvbmNhdChuZXdWYWx1ZSwgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcC5zZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZ2V0UHJvZ3Jlc3MoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCB2YWx1ZXMgIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcHJvZ3Jlc3MgPSAodGhpcy5kdXJhdGlvbiAtIHRoaXMuYmVnaW4pIC8gKHRoaXMubWF4RHVyYXRpb24gLSB0aGlzLmJlZ2luKTtcbiAgICAgICAgbGV0IGZyb207XG4gICAgICAgIGxldCB0bztcbiAgICAgICAgaWYgKHZhbHVlcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcHJvZ3Jlc3MgKiAodmFsdWVzLmdldFZhbHVlKCkubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBjb25zdCBsYiA9IE1hdGguZmxvb3IocCk7XG4gICAgICAgICAgICBjb25zdCB1YiA9IE1hdGguY2VpbChwKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmdldFZhbHVlKClbbGJdO1xuICAgICAgICAgICAgZnJvbSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2Zyb20nLCB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogMCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5nZXRWYWx1ZSgpW3ViXTtcbiAgICAgICAgICAgIHRvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndG8nLCB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogMCk7XG4gICAgICAgICAgICBwcm9ncmVzcyA9IChwIC0gbGIpIC8gKHViIC0gbGIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICAgIHRvID0gdGhpcy50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG9cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdhbmltYXRlJztcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuaW5pdGlhbFVuaXRzID0gJyc7XG4gICAgICAgIHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgICAgICBkb2N1bWVudC5zY3JlZW4uYW5pbWF0aW9ucy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLmJlZ2luID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2JlZ2luJykuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgICAgIHRoaXMubWF4RHVyYXRpb24gPSB0aGlzLmJlZ2luICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ2R1cicpLmdldE1pbGxpc2Vjb25kcygpO1xuICAgICAgICB0aGlzLmZyb20gPSB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RvJyk7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndmFsdWVzJywgbnVsbCk7XG4gICAgICAgIGNvbnN0IHZhbHVlc0F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJyk7XG4gICAgICAgIGlmICh2YWx1ZXNBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNldFZhbHVlKHZhbHVlc0F0dHIuZ2V0U3RyaW5nKCkuc3BsaXQoJzsnKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFuaW1hdGVDb2xvckVsZW1lbnQgZXh0ZW5kcyBBbmltYXRlRWxlbWVudCB7XG4gICAgY2FsY1ZhbHVlKCkge1xuICAgICAgICBjb25zdCB7IHByb2dyZXNzICwgZnJvbSAsIHRvICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpO1xuICAgICAgICBjb25zdCBjb2xvckZyb20gPSBuZXcgUkdCQ29sb3IoZnJvbS5nZXRDb2xvcigpKTtcbiAgICAgICAgY29uc3QgY29sb3JUbyA9IG5ldyBSR0JDb2xvcih0by5nZXRDb2xvcigpKTtcbiAgICAgICAgaWYgKGNvbG9yRnJvbS5vayAmJiBjb2xvclRvLm9rKSB7XG4gICAgICAgICAgICAvLyB0d2VlbiBjb2xvciBsaW5lYXJseVxuICAgICAgICAgICAgY29uc3QgciA9IGNvbG9yRnJvbS5yICsgKGNvbG9yVG8uciAtIGNvbG9yRnJvbS5yKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgY29uc3QgZyA9IGNvbG9yRnJvbS5nICsgKGNvbG9yVG8uZyAtIGNvbG9yRnJvbS5nKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgY29uc3QgYiA9IGNvbG9yRnJvbS5iICsgKGNvbG9yVG8uYiAtIGNvbG9yRnJvbS5iKSAqIHByb2dyZXNzO1xuICAgICAgICAgICAgLy8gPyBhbHBoYVxuICAgICAgICAgICAgcmV0dXJuIFwicmdiKFwiLmNvbmNhdChNYXRoLmZsb29yKHIpLCBcIiwgXCIpLmNvbmNhdChNYXRoLmZsb29yKGcpLCBcIiwgXCIpLmNvbmNhdChNYXRoLmZsb29yKGIpLCBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJykuZ2V0Q29sb3IoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZUNvbG9yJztcbiAgICB9XG59XG5cbmNsYXNzIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50IGV4dGVuZHMgQW5pbWF0ZUVsZW1lbnQge1xuICAgIGNhbGNWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9ncmVzcyAsIGZyb206IGZyb20xICwgdG86IHRvMSAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTtcbiAgICAgICAgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtRnJvbSA9IHRvTnVtYmVycyhmcm9tMS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVRvID0gdG9OdW1iZXJzKHRvMS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdHJhbnNmb3JtRnJvbS5tYXAoKGZyb20sIGkpPT57XG4gICAgICAgICAgICBjb25zdCB0byA9IHRyYW5zZm9ybVRvW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xuICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYW5pbWF0ZVRyYW5zZm9ybSc7XG4gICAgfVxufVxuXG5jbGFzcyBGb250RmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZvbnQtZmFjZSc7XG4gICAgICAgIHRoaXMuYXNjZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FzY2VudCcpLmdldE51bWJlcigpO1xuICAgICAgICB0aGlzLmRlc2NlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGVzY2VudCcpLmdldE51bWJlcigpO1xuICAgICAgICB0aGlzLnVuaXRzUGVyRW0gPSB0aGlzLmdldEF0dHJpYnV0ZSgndW5pdHMtcGVyLWVtJykuZ2V0TnVtYmVyKCk7XG4gICAgfVxufVxuXG5jbGFzcyBHbHlwaEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdnbHlwaCc7XG4gICAgICAgIHRoaXMuaG9yaXpBZHZYID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hvcml6LWFkdi14JykuZ2V0TnVtYmVyKCk7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd1bmljb2RlJykuZ2V0U3RyaW5nKCk7XG4gICAgICAgIHRoaXMuYXJhYmljRm9ybSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhcmFiaWMtZm9ybScpLmdldFN0cmluZygpO1xuICAgIH1cbn1cblxuY2xhc3MgTWlzc2luZ0dseXBoRWxlbWVudCBleHRlbmRzIEdseXBoRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbWlzc2luZy1nbHlwaCc7XG4gICAgICAgIHRoaXMuaG9yaXpBZHZYID0gMDtcbiAgICB9XG59XG5cbmNsYXNzIEZvbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZvbnQnO1xuICAgICAgICB0aGlzLmlzQXJhYmljID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2x5cGhzID0ge307XG4gICAgICAgIHRoaXMuYXJhYmljR2x5cGhzID0ge307XG4gICAgICAgIHRoaXMuaXNSVEwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ob3JpekFkdlggPSB0aGlzLmdldEF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5nZXROdW1iZXIoKTtcbiAgICAgICAgY29uc3QgeyBkZWZpbml0aW9ucyAgfSA9IGRvY3VtZW50O1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuICB9ID0gdGhpcztcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbil7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBGb250RmFjZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvbnRGYWNlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9udEZhbWlseVN0eWxlID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnRGYW1pbHlTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zW2ZvbnRGYW1pbHlTdHlsZS5nZXRTdHJpbmcoKV0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBNaXNzaW5nR2x5cGhFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXNzaW5nR2x5cGggPSBjaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHbHlwaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYXJhYmljRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUlRMID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0FyYWJpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyYWJpY0dseXBoID0gdGhpcy5hcmFiaWNHbHlwaHNbY2hpbGQudW5pY29kZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJhYmljR2x5cGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyYWJpY0dseXBoc1tjaGlsZC51bmljb2RlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2hpbGQuYXJhYmljRm9ybV06IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJhYmljR2x5cGhbY2hpbGQuYXJhYmljRm9ybV0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBUUmVmRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgICBnZXRUZXh0KCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkLmdldFRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RyZWYnO1xuICAgIH1cbn1cblxuY2xhc3MgQUVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZXh0IGVsZW1lbnRcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlckNoaWxkcmVuKGN0eCk7XG4gICAgICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgeCAsIHkgIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBtb3VzZSAgfSA9IGRvY3VtZW50LnNjcmVlbjtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZm9udFNpemUnLCBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZSk7XG4gICAgICAgICAgICAvLyBEbyBub3QgY2FsYyBib3VuZGluZyBib3ggaWYgbW91c2UgaXMgbm90IHdvcmtpbmcuXG4gICAgICAgICAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgICAgICAgICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIG5ldyBCb3VuZGluZ0JveCh4LCB5IC0gZm9udFNpemUuZ2V0UGl4ZWxzKCd5JyksIHggKyB0aGlzLm1lYXN1cmVUZXh0KGN0eCksIHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wb3JhcnkgZ3JvdXBcbiAgICAgICAgICAgIGNvbnN0IGcgPSBuZXcgR0VsZW1lbnQodGhpcy5kb2N1bWVudCk7XG4gICAgICAgICAgICBnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgICAgICAgIGcucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIGcucmVuZGVyKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgY29uc3QgeyB3aW5kb3cgIH0gPSB0aGlzLmRvY3VtZW50O1xuICAgICAgICBpZiAod2luZG93KSB7XG4gICAgICAgICAgICB3aW5kb3cub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Nb3VzZU1vdmUoKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuZG9jdW1lbnQuY3R4O1xuICAgICAgICBjdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUxLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUxLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2EnO1xuICAgICAgICBjb25zdCB7IGNoaWxkTm9kZXMgIH0gPSBub2RlMTtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGNoaWxkTm9kZXNbMF07XG4gICAgICAgIGNvbnN0IGhhc1RleHQgPSBjaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgQXJyYXkuZnJvbShjaGlsZE5vZGVzKS5ldmVyeSgobm9kZSk9Pm5vZGUubm9kZVR5cGUgPT09IDNcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5oYXNUZXh0ID0gaGFzVGV4dDtcbiAgICAgICAgdGhpcy50ZXh0ID0gaGFzVGV4dCA/IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKGZpcnN0Q2hpbGQpIDogJyc7XG4gICAgfVxufVxuXG5jbGFzcyBUZXh0UGF0aEVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgcGF0aChjdHgpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhQXJyYXkgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YUFycmF5LmZvckVhY2goKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgdHlwZSAsIHBvaW50cyAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgc3dpdGNoKHR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnNdID0gcG9pbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKHBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgQm9vbGVhbigxIC0gZnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlWCwgMSAvIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgtcHNpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgICB0aGlzLnNldFRleHREYXRhKGN0eCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGNvbnN0IHRleHREZWNvcmF0aW9uID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtZGVjb3JhdGlvbicpLmdldFN0cmluZygpO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgICAgY29uc3QgeyBnbHlwaEluZm8gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBmaWxsID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGdseXBoSW5mby5mb3JFYWNoKChnbHlwaCwgaSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgcDAgLCBwMSAsIHJvdGF0aW9uICwgdGV4dDogcGFydGlhbFRleHQgIH0gPSBnbHlwaDtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICAgICAgICBpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChwYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAwLngsIHAwLnkgKyBmb250U2l6ZSAvIDgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkgKyBmb250U2l6ZSAvIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyAvLyBUbyBhc3Npc3Qgd2l0aCBkZWJ1Z2dpbmcgdmlzdWFsbHksIHVuY29tbWVudCBmb2xsb3dpbmdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAvLyBpZiAoaSAlIDIpXG4gICAgICAgIC8vICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIC8vIGVsc2VcbiAgICAgICAgLy8gICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAvLyBjdHgubW92ZVRvKHAwLngsIHAwLnkpO1xuICAgICAgICAvLyBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAgIC8vIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBmb250U2l6ZSAvIDIwO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBnZXRMZXR0ZXJTcGFjaW5nQXQoKSB7XG4gICAgICAgIGxldCBpZHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmxldHRlclNwYWNpbmdDYWNoZVtpZHhdIHx8IDA7XG4gICAgfVxuICAgIGZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIGlucHV0T2Zmc2V0LCBkeSwgYywgY2hhckkpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICAgICAgICBsZXQgZ2x5cGhXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4LCBjKTtcbiAgICAgICAgaWYgKGMgPT09ICcgJyAmJiBhbmNob3IgPT09ICdqdXN0aWZ5JyAmJiB0ZXh0RnVsbFdpZHRoIDwgZnVsbFBhdGhXaWR0aCkge1xuICAgICAgICAgICAgZ2x5cGhXaWR0aCArPSAoZnVsbFBhdGhXaWR0aCAtIHRleHRGdWxsV2lkdGgpIC8gc3BhY2VzTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFySSA+IC0xKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nQXQoY2hhckkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGluZVN0ZXAgPSB0aGlzLnRleHRIZWlnaHQgLyAyMDtcbiAgICAgICAgY29uc3QgcDAgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0LCBzcGxpbmVTdGVwLCAwKTtcbiAgICAgICAgY29uc3QgcDEgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0ICsgZ2x5cGhXaWR0aCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSB7XG4gICAgICAgICAgICBwMCxcbiAgICAgICAgICAgIHAxXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gcDAgJiYgcDEgPyBNYXRoLmF0YW4yKHAxLnkgLSBwMC55LCBwMS54IC0gcDAueCkgOiAwO1xuICAgICAgICBpZiAoZHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGR5WCA9IE1hdGguY29zKE1hdGguUEkgLyAyICsgcm90YXRpb24pICogZHk7XG4gICAgICAgICAgICBjb25zdCBkeVkgPSBNYXRoLmNvcygtcm90YXRpb24pICogZHk7XG4gICAgICAgICAgICBzZWdtZW50LnAwID0ge1xuICAgICAgICAgICAgICAgIC4uLnAwLFxuICAgICAgICAgICAgICAgIHg6IHAwLnggKyBkeVgsXG4gICAgICAgICAgICAgICAgeTogcDAueSArIGR5WVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlZ21lbnQucDEgPSB7XG4gICAgICAgICAgICAgICAgLi4ucDEsXG4gICAgICAgICAgICAgICAgeDogcDEueCArIGR5WCxcbiAgICAgICAgICAgICAgICB5OiBwMS55ICsgZHlZXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBnbHlwaFdpZHRoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICAgIHJvdGF0aW9uXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0KGN0eCwgdGV4dCkge1xuICAgICAgICBjb25zdCB7IG1lYXN1cmVzQ2FjaGUgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0YXJnZXRUZXh0ID0gdGV4dCB8fCB0aGlzLmdldFRleHQoKTtcbiAgICAgICAgaWYgKG1lYXN1cmVzQ2FjaGUuaGFzKHRhcmdldFRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVhc3VyZXNDYWNoZS5nZXQodGFyZ2V0VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVhc3VyZSA9IHRoaXMubWVhc3VyZVRhcmdldFRleHQoY3R4LCB0YXJnZXRUZXh0KTtcbiAgICAgICAgbWVhc3VyZXNDYWNoZS5zZXQodGFyZ2V0VGV4dCwgbWVhc3VyZSk7XG4gICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBzdXBwb3NlcyB3aGF0IGFsbCBjdXN0b20gZm9udHMgYWxyZWFkeSBsb2FkZWQuXG4gICAgLy8gSWYgc29tZSBmb250IHdpbGwgYmUgbG9hZGVkIGFmdGVyIHRoaXMgbWV0aG9kIGNhbGwsIDx0ZXh0UGF0aD4gd2lsbCBub3QgYmUgcmVuZGVyZWQgY29ycmVjdGx5LlxuICAgIC8vIFlvdSBuZWVkIHRvIGNhbGwgdGhpcyBtZXRob2QgbWFudWFsbHkgdG8gdXBkYXRlIGdseXBocyBjYWNoZS5cbiAgICBzZXRUZXh0RGF0YShjdHgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2x5cGhJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBjaGFycyA9IHJlbmRlclRleHQuc3BsaXQoJycpO1xuICAgICAgICBjb25zdCBzcGFjZXNOdW1iZXIgPSByZW5kZXJUZXh0LnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgZHggPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4Jykuc3BsaXQoKS5tYXAoKF8pPT5fLmdldFBpeGVscygneCcpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGR5ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLnBhcmVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgICAgIGNvbnN0IHRoaXNTcGFjaW5nID0gdGhpcy5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICAgICAgY29uc3QgcGFyZW50U3BhY2luZyA9IHRoaXMucGFyZW50LmdldFN0eWxlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgICAgICBsZXQgbGV0dGVyU3BhY2luZyA9IDA7XG4gICAgICAgIGlmICghdGhpc1NwYWNpbmcuaGFzVmFsdWUoKSB8fCB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmcgPSBwYXJlbnRTcGFjaW5nLmdldFBpeGVscygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXNTcGFjaW5nLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzU3BhY2luZy5nZXRWYWx1ZSgpICE9PSAnaW5pdGlhbCcgJiYgdGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ3Vuc2V0Jykge1xuICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmcgPSB0aGlzU3BhY2luZy5nZXRQaXhlbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaWxsIGxldHRlci1zcGFjaW5nIGNhY2hlXG4gICAgICAgIGNvbnN0IGxldHRlclNwYWNpbmdDYWNoZSA9IFtdO1xuICAgICAgICBjb25zdCB0ZXh0TGVuID0gcmVuZGVyVGV4dC5sZW5ndGg7XG4gICAgICAgIHRoaXMubGV0dGVyU3BhY2luZ0NhY2hlID0gbGV0dGVyU3BhY2luZ0NhY2hlO1xuICAgICAgICBmb3IobGV0IGkxID0gMDsgaTEgPCB0ZXh0TGVuOyBpMSsrKXtcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmdDYWNoZS5wdXNoKHR5cGVvZiBkeFtpMV0gIT09ICd1bmRlZmluZWQnID8gZHhbaTFdIDogbGV0dGVyU3BhY2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHhTdW0gPSBsZXR0ZXJTcGFjaW5nQ2FjaGUucmVkdWNlKChhY2MsIGN1ciwgaSk9PmkgPT09IDAgPyAwIDogYWNjICsgY3VyIHx8IDBcbiAgICAgICAgLCAwKTtcbiAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChjdHgpO1xuICAgICAgICBjb25zdCB0ZXh0RnVsbFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoICsgZHhTdW0sIDApO1xuICAgICAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xuICAgICAgICBjb25zdCBmdWxsUGF0aFdpZHRoID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5nZXRTdHlsZSgnc3RhcnRPZmZzZXQnKS5nZXROdW1iZXIoMCkgKiBmdWxsUGF0aFdpZHRoO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGFuY2hvciA9PT0gJ21pZGRsZScgfHwgYW5jaG9yID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLXRleHRGdWxsV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNob3IgPT09ICdlbmQnIHx8IGFuY2hvciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLXRleHRGdWxsV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICBjaGFycy5mb3JFYWNoKChjaGFyLCBpKT0+e1xuICAgICAgICAgICAgLy8gRmluZCBzdWNoIHNlZ21lbnQgd2hhdCBkaXN0YW5jZSBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICAgICAgICBjb25zdCB7IG9mZnNldDogbmV4dE9mZnNldCAsIHNlZ21lbnQgLCByb3RhdGlvbiAgfSA9IHRoaXMuZmluZFNlZ21lbnRUb0ZpdENoYXIoY3R4LCBhbmNob3IsIHRleHRGdWxsV2lkdGgsIGZ1bGxQYXRoV2lkdGgsIHNwYWNlc051bWJlciwgb2Zmc2V0LCBkeSwgY2hhciwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCFzZWdtZW50LnAwIHx8ICFzZWdtZW50LnAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc3Qgd2lkdGggPSB0aGlzLmdldExpbmVMZW5ndGgoXG4gICAgICAgICAgICAvLyAgIHNlZ21lbnQucDAueCxcbiAgICAgICAgICAgIC8vICAgc2VnbWVudC5wMC55LFxuICAgICAgICAgICAgLy8gICBzZWdtZW50LnAxLngsXG4gICAgICAgICAgICAvLyAgIHNlZ21lbnQucDEueVxuICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFNpbmNlIGdseXBocyBhcmUgcmVuZGVyZWQgb25lIGF0IGEgdGltZSwgYW55IGtlcm5pbmcgcGFpciBkYXRhIGJ1aWx0IGludG8gdGhlIGZvbnQgd2lsbCBub3QgYmUgdXNlZC5cbiAgICAgICAgICAgIC8vIENhbiBmb3Jlc2VlIGhhdmluZyBhIHJvdWdoIHBhaXIgdGFibGUgYnVpbHQgaW4gdGhhdCB0aGUgZGV2ZWxvcGVyIGNhbiBvdmVycmlkZSBhcyBuZWVkZWQuXG4gICAgICAgICAgICAvLyBPciB1c2UgXCJkeFwiIGF0dHJpYnV0ZSBvZiB0aGUgPHRleHQ+IG5vZGUgYXMgYSBuYWl2ZSByZXBsYWNlbWVudFxuICAgICAgICAgICAgLy8gY29uc3Qga2VybiA9IDA7XG4gICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgICAvLyBjb25zdCBtaWRwb2ludCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoXG4gICAgICAgICAgICAvLyAgIGtlcm4gKyB3aWR0aCAvIDIuMCxcbiAgICAgICAgICAgIC8vICAgc2VnbWVudC5wMC54LCBzZWdtZW50LnAwLnksIHNlZ21lbnQucDEueCwgc2VnbWVudC5wMS55XG4gICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgdGhpcy5nbHlwaEluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNwb3NlWDogbWlkcG9pbnQueCxcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICAgICAgICAgIHRleHQ6IGNoYXJzW2ldLFxuICAgICAgICAgICAgICAgIHAwOiBzZWdtZW50LnAwLFxuICAgICAgICAgICAgICAgIHAxOiBzZWdtZW50LnAxLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlUGF0aERhdGEocGF0aCkge1xuICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSAtMSAvLyByZXNldCBwYXRoIGxlbmd0aFxuICAgICAgICA7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGhDb21tYW5kcyA9IFtdO1xuICAgICAgICBjb25zdCB7IHBhdGhQYXJzZXIgIH0gPSBwYXRoO1xuICAgICAgICBwYXRoUGFyc2VyLnJlc2V0KCk7XG4gICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICB3aGlsZSghcGF0aFBhcnNlci5pc0VuZCgpKXtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudCAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSBjdXJyZW50ID8gY3VycmVudC54IDogMDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WSA9IGN1cnJlbnQgPyBjdXJyZW50LnkgOiAwO1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHBhdGhQYXJzZXIubmV4dCgpO1xuICAgICAgICAgICAgbGV0IG5leHRDb21tYW5kVHlwZSA9IGNvbW1hbmQudHlwZTtcbiAgICAgICAgICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHN3aXRjaChjb21tYW5kLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhNKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhMKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5IT1JJWl9MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFYocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhDKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfQ1VSVkVfVE86XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aFEocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHRoaXMucGF0aEEocGF0aFBhcnNlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgICAgICAgICBQYXRoRWxlbWVudC5wYXRoWihwYXRoUGFyc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWFuZC50eXBlICE9PSBQYXRoUGFyc2VyLkNMT1NFX1BBVEgpIHtcbiAgICAgICAgICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG5leHRDb21tYW5kVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc3RhcnRZXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhdGhMZW5ndGg6IHRoaXMuY2FsY0xlbmd0aChzdGFydFgsIHN0YXJ0WSwgbmV4dENvbW1hbmRUeXBlLCBwb2ludHMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGF0aFBhcnNlci5DTE9TRV9QQVRILFxuICAgICAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBwYXRoTGVuZ3RoOiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhDb21tYW5kcztcbiAgICB9XG4gICAgcGF0aE0ocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBQYXRoRWxlbWVudC5wYXRoTShwYXRoUGFyc2VyKS5wb2ludDtcbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgfVxuICAgIHBhdGhMKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICAgIH1cbiAgICBwYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IFBhdGhFbGVtZW50LnBhdGhIKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgICB9XG4gICAgcGF0aFYocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKS5wb2ludDtcbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gICAgfVxuICAgIHBhdGhDKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgICBjb25zdCB7IHBvaW50ICwgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gICAgcGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgcG9pbnQgLCBjb250cm9sUG9pbnQgLCBjdXJyZW50UG9pbnQgIH0gPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKTtcbiAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgICByZXR1cm4gUGF0aFBhcnNlci5DVVJWRV9UTztcbiAgICB9XG4gICAgcGF0aFEocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgICAgIHBvaW50cy5wdXNoKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gICAgcGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHsgY29udHJvbFBvaW50ICwgY3VycmVudFBvaW50ICB9ID0gUGF0aEVsZW1lbnQucGF0aFQocGF0aFBhcnNlcik7XG4gICAgICAgIHBvaW50cy5wdXNoKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuUVVBRF9UTztcbiAgICB9XG4gICAgcGF0aEEocGF0aFBhcnNlcikge1xuICAgICAgICBsZXQgeyByWCAsIHJZICwgc3dlZXBGbGFnICwgeEF4aXNSb3RhdGlvbiAsIGNlbnRwICwgYTEgLCBhZCAgfSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpO1xuICAgICAgICBpZiAoc3dlZXBGbGFnID09PSAwICYmIGFkID4gMCkge1xuICAgICAgICAgICAgYWQgLT0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhZCA8IDApIHtcbiAgICAgICAgICAgIGFkICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjZW50cC54LFxuICAgICAgICAgICAgY2VudHAueSxcbiAgICAgICAgICAgIHJYLFxuICAgICAgICAgICAgclksXG4gICAgICAgICAgICBhMSxcbiAgICAgICAgICAgIGFkLFxuICAgICAgICAgICAgeEF4aXNSb3RhdGlvbixcbiAgICAgICAgICAgIHN3ZWVwRmxhZ1xuICAgICAgICBdO1xuICAgIH1cbiAgICBjYWxjTGVuZ3RoKHgsIHksIGNvbW1hbmRUeXBlLCBwb2ludHMpIHtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGxldCBwMSA9IG51bGw7XG4gICAgICAgIGxldCBwMiA9IG51bGw7XG4gICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgc3dpdGNoKGNvbW1hbmRUeXBlKXtcbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgICAgICAgIGZvcih0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpe1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgZm9yKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSl7XG4gICAgICAgICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW47XG4gICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gbGluZSBzZWdtZW50c1xuICAgICAgICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IHBvaW50c1s0XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRUaGV0YSA9IHBvaW50c1s1XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gNSA9IGRUaGV0YVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBwb2ludHNbNF0gKyBkVGhldGE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmMgPSBNYXRoLlBJIC8gMTgwO1xuICAgICAgICAgICAgICAgICAgICAvLyAxIGRlZ3JlZSByZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYyA9IE1hdGguYWJzKHN0YXJ0IC0gZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBmb3IgcHVycG9zZSBvZiBjYWxjdWxhdGluZyBhcmMgbGVuZ3RoLCBub3QgZ29pbmcgdG8gd29ycnkgYWJvdXQgcm90YXRpbmcgWC1heGlzIGJ5IGFuZ2xlIHBzaVxuICAgICAgICAgICAgICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBzdGFydCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwMiA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBlbmQsIDApO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0UG9pbnRPbkxpbmUoZGlzdCwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgICAgIGxldCBmcm9tWCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzVdIDogcDF4LCBmcm9tWSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzZdIDogcDF5O1xuICAgICAgICBjb25zdCBtID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4ICsgUFNFVURPX1pFUk8pO1xuICAgICAgICBsZXQgcnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC8gKDEgKyBtICogbSkpO1xuICAgICAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICAgICAgICBydW4gKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJpc2UgPSBtICogcnVuO1xuICAgICAgICBsZXQgcHQgPSBudWxsO1xuICAgICAgICBpZiAocDJ4ID09PSBwMXgpIHtcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGZyb21YLFxuICAgICAgICAgICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgoZnJvbVkgLSBwMXkpIC8gKGZyb21YIC0gcDF4ICsgUFNFVURPX1pFUk8pID09PSBtKSB7XG4gICAgICAgICAgICBwdCA9IHtcbiAgICAgICAgICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaXggPSAwO1xuICAgICAgICAgICAgbGV0IGl5ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuZ2V0TGluZUxlbmd0aChwMXgsIHAxeSwgcDJ4LCBwMnkpO1xuICAgICAgICAgICAgaWYgKGxlbiA8IFBTRVVET19aRVJPKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdSA9IChmcm9tWCAtIHAxeCkgKiAocDJ4IC0gcDF4KSArIChmcm9tWSAtIHAxeSkgKiAocDJ5IC0gcDF5KTtcbiAgICAgICAgICAgIHUgLz0gbGVuICogbGVuO1xuICAgICAgICAgICAgaXggPSBwMXggKyB1ICogKHAyeCAtIHAxeCk7XG4gICAgICAgICAgICBpeSA9IHAxeSArIHUgKiAocDJ5IC0gcDF5KTtcbiAgICAgICAgICAgIGNvbnN0IHBSaXNlID0gdGhpcy5nZXRMaW5lTGVuZ3RoKGZyb21YLCBmcm9tWSwgaXgsIGl5KTtcbiAgICAgICAgICAgIGNvbnN0IHBSdW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLSBwUmlzZSAqIHBSaXNlKTtcbiAgICAgICAgICAgIHJ1biA9IE1hdGguc3FydChwUnVuICogcFJ1biAvICgxICsgbSAqIG0pKTtcbiAgICAgICAgICAgIGlmIChwMnggPCBwMXgpIHtcbiAgICAgICAgICAgICAgICBydW4gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByaXNlID0gbSAqIHJ1bjtcbiAgICAgICAgICAgIHB0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGl4ICsgcnVuLFxuICAgICAgICAgICAgICAgIHk6IGl5ICsgcmlzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHQ7XG4gICAgfVxuICAgIGdldFBvaW50T25QYXRoKGRpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxMZW4gPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICAgICAgbGV0IGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IHAgPSBudWxsO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCAtMC4wMDAwNSB8fCBkaXN0YW5jZSAtIDAuMDAwMDUgPiBmdWxsTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGRhdGFBcnJheSAgfSA9IHRoaXM7XG4gICAgICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBkYXRhQXJyYXkpe1xuICAgICAgICAgICAgaWYgKGNvbW1hbmQgJiYgKGNvbW1hbmQucGF0aExlbmd0aCA8IDAuMDAwMDUgfHwgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggKyAwLjAwMDA1IDwgZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKz0gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBkaXN0YW5jZSAtIGN1bXVsYXRpdmVQYXRoTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRUID0gMDtcbiAgICAgICAgICAgIHN3aXRjaChjb21tYW5kLnR5cGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uTGluZShkZWx0YSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGNvbW1hbmQucG9pbnRzWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkVGhldGEgPSBjb21tYW5kLnBvaW50c1s1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGNvbW1hbmQucG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoICogZFRoZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQgfHwgZFRoZXRhID49IDAgJiYgY3VycmVudFQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjdXJyZW50VCwgY29tbWFuZC5wb2ludHNbNl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIoY3VycmVudFQsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSwgY29tbWFuZC5wb2ludHNbNF0sIGNvbW1hbmQucG9pbnRzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0TGluZUxlbmd0aCh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgfVxuICAgIGdldFBhdGhMZW5ndGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSB0aGlzLmRhdGFBcnJheS5yZWR1Y2UoKGxlbmd0aCwgY29tbWFuZCk9PmNvbW1hbmQucGF0aExlbmd0aCA+IDAgPyBsZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggOiBsZW5ndGhcbiAgICAgICAgICAgICwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aExlbmd0aDtcbiAgICB9XG4gICAgZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICAgICAgY29uc3QgeCA9IHA0eCAqIENCMShwY3QpICsgcDN4ICogQ0IyKHBjdCkgKyBwMnggKiBDQjMocGN0KSArIHAxeCAqIENCNChwY3QpO1xuICAgICAgICBjb25zdCB5ID0gcDR5ICogQ0IxKHBjdCkgKyBwM3kgKiBDQjIocGN0KSArIHAyeSAqIENCMyhwY3QpICsgcDF5ICogQ0I0KHBjdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgICAgICBjb25zdCB4ID0gcDN4ICogUUIxKHBjdCkgKyBwMnggKiBRQjIocGN0KSArIHAxeCAqIFFCMyhwY3QpO1xuICAgICAgICBjb25zdCB5ID0gcDN5ICogUUIxKHBjdCkgKyBwMnkgKiBRQjIocGN0KSArIHAxeSAqIFFCMyhwY3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpIHtcbiAgICAgICAgY29uc3QgY29zUHNpID0gTWF0aC5jb3MocHNpKTtcbiAgICAgICAgY29uc3Qgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICAgICAgY29uc3QgcHQgPSB7XG4gICAgICAgICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjeCArIChwdC54ICogY29zUHNpIC0gcHQueSAqIHNpblBzaSksXG4gICAgICAgICAgICB5OiBjeSArIChwdC54ICogc2luUHNpICsgcHQueSAqIGNvc1BzaSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVE9ETyBuZWVkIHNvbWUgb3B0aW1pc2F0aW9ucy4gcG9zc2libHkgYnVpbGQgY2FjaGUgb25seSBmb3IgY3VydmVkIHNlZ21lbnRzP1xuICAgIGJ1aWxkRXF1aWRpc3RhbnRDYWNoZShpbnB1dFN0ZXAsIGlucHV0UHJlY2lzaW9uKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxMZW4gPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gaW5wdXRQcmVjaXNpb24gfHwgMC4yNSAvLyBhY2N1cmFjeSB2cyBwZXJmb3JtYW5jZVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBpbnB1dFN0ZXAgfHwgZnVsbExlbiAvIDEwMDtcbiAgICAgICAgaWYgKCF0aGlzLmVxdWlkaXN0YW50Q2FjaGUgfHwgdGhpcy5lcXVpZGlzdGFudENhY2hlLnN0ZXAgIT09IHN0ZXAgfHwgdGhpcy5lcXVpZGlzdGFudENhY2hlLnByZWNpc2lvbiAhPT0gcHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIGNhY2hlXG4gICAgICAgICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgc3RlcCxcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb2ludHNcbiAgICAgICAgICAgIGxldCBzID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgbCA9IDA7IGwgPD0gZnVsbExlbjsgbCArPSBwcmVjaXNpb24pe1xuICAgICAgICAgICAgICAgIGNvbnN0IHAwID0gdGhpcy5nZXRQb2ludE9uUGF0aChsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwMSA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCArIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFwMCB8fCAhcDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMgKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuICAgICAgICAgICAgICAgIGlmIChzID49IHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcXVpZGlzdGFudENhY2hlLnBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHAwLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwMC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2U6IGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHMgLT0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aCh0YXJnZXREaXN0YW5jZSwgc3RlcCwgcHJlY2lzaW9uKSB7XG4gICAgICAgIHRoaXMuYnVpbGRFcXVpZGlzdGFudENhY2hlKHN0ZXAsIHByZWNpc2lvbik7XG4gICAgICAgIGlmICh0YXJnZXREaXN0YW5jZSA8IDAgfHwgdGFyZ2V0RGlzdGFuY2UgLSB0aGlzLmdldFBhdGhMZW5ndGgoKSA+IDAuMDAwMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeCA9IE1hdGgucm91bmQodGFyZ2V0RGlzdGFuY2UgLyB0aGlzLmdldFBhdGhMZW5ndGgoKSAqICh0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHNbaWR4XSB8fCBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RleHRQYXRoJztcbiAgICAgICAgdGhpcy50ZXh0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSAtMTtcbiAgICAgICAgdGhpcy5nbHlwaEluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLm1lYXN1cmVzQ2FjaGUgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICBdXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBwYXRoRWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgICAgICAgdGhpcy5kYXRhQXJyYXkgPSB0aGlzLnBhcnNlUGF0aERhdGEocGF0aEVsZW1lbnQpO1xuICAgIH1cbn1cblxuLy8gZ3JvdXBzOiAxOiBtaW1lLXR5cGUgKCsgY2hhcnNldCksIDI6IG1pbWUtdHlwZSAody9vIGNoYXJzZXQpLCAzOiBjaGFyc2V0LCA0OiBiYXNlNjQ/LCA1OiBib2R5XG5jb25zdCBkYXRhVXJpUmVnZXggPSAvXlxccypkYXRhOigoW14vLDtdK1xcL1teLyw7XSspKD86OyhbXiw7PV0rPVteLDs9XSspKT8pPyg/OjsoYmFzZTY0KSk/LCguKikkL2k7XG5jbGFzcyBJbWFnZUVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIGFzeW5jIGxvYWRJbWFnZShocmVmKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGF3YWl0IHRoaXMuZG9jdW1lbnQuY3JlYXRlSW1hZ2UoaHJlZik7XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZFN2ZyhocmVmKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZGF0YVVyaVJlZ2V4LmV4ZWMoaHJlZik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1hdGNoWzVdO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbNF0gPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBhdG9iKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBkZWNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZG9jdW1lbnQuZmV0Y2goaHJlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ZnID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBzdmc7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBpbWFnZSBcXFwiXCIuY29uY2F0KGhyZWYsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIGltYWdlICwgbG9hZGVkICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuICAgICAgICBpZiAoIWxvYWRlZCB8fCAhaW1hZ2UgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qgc3ViRG9jdW1lbnQgPSBkb2N1bWVudC5jYW52Zy5mb3JrU3RyaW5nKGN0eCwgaW1hZ2UsIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgICAgICAgc2NhbGVXaWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgc2NhbGVIZWlnaHQ6IGhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRvY3VtZW50RWxlbWVudCAgfSA9IHN1YkRvY3VtZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCBzdWJEb2N1bWVudC5yZW5kZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnNldFZpZXdCb3goe1xuICAgICAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBkZXNpcmVkV2lkdGg6IGltYWdlLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBkZXNpcmVkSGVpZ2h0OiBpbWFnZS5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoJ2NvbXBsZXRlJyBpbiBpbWFnZSkgfHwgaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGdldEJvdW5kaW5nQm94KCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdpbWFnZSc7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGhyZWYgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKTtcbiAgICAgICAgaWYgKCFocmVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTdmcgPSBocmVmLmVuZHNXaXRoKCcuc3ZnJykgfHwgL15cXHMqZGF0YTppbWFnZVxcL3N2Z1xcK3htbC9pLnRlc3QoaHJlZik7XG4gICAgICAgIGRvY3VtZW50LmltYWdlcy5wdXNoKHRoaXMpO1xuICAgICAgICBpZiAoIWlzU3ZnKSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMubG9hZEltYWdlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdm9pZCB0aGlzLmxvYWRTdmcoaHJlZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFN5bWJvbEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICAgIHJlbmRlcihfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3N5bWJvbCc7XG4gICAgfVxufVxuXG5jbGFzcyBTVkdGb250TG9hZGVyIHtcbiAgICBhc3luYyBsb2FkKGZvbnRGYW1pbHksIHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzdmdEb2N1bWVudCA9IGF3YWl0IGRvY3VtZW50LmNhbnZnLnBhcnNlci5sb2FkKHVybCk7XG4gICAgICAgICAgICBjb25zdCBmb250cyA9IHN2Z0RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb250Jyk7XG4gICAgICAgICAgICBBcnJheS5mcm9tKGZvbnRzKS5mb3JFYWNoKChmb250Tm9kZSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBmb250ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChmb250Tm9kZSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGVmaW5pdGlvbnNbZm9udEZhbWlseV0gPSBmb250O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgZm9udCBcXFwiXCIuY29uY2F0KHVybCwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50KXtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBkb2N1bWVudC5mb250cy5wdXNoKHRoaXMpO1xuICAgIH1cbn1cblxuY2xhc3MgU3R5bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgICAgIGNvbnN0IGNzcyA9IGNvbXByZXNzU3BhY2VzKEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS8vIE5FRUQgVEVTVFxuICAgICAgICAubWFwKChfKT0+Xy50ZXh0Q29udGVudFxuICAgICAgICApLmpvaW4oJycpLnJlcGxhY2UoLyhcXC9cXCooW14qXXxbXFxyXFxuXXwoXFwqKyhbXiovXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICAucmVwbGFjZSgvQGltcG9ydC4qOy9nLCAnJykgLy8gcmVtb3ZlIGltcG9ydHNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY3NzRGVmcyA9IGNzcy5zcGxpdCgnfScpO1xuICAgICAgICBjc3NEZWZzLmZvckVhY2goKF8xKT0+e1xuICAgICAgICAgICAgY29uc3QgZGVmID0gXzEudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFkZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjc3NQYXJ0cyA9IGRlZi5zcGxpdCgneycpO1xuICAgICAgICAgICAgY29uc3QgY3NzQ2xhc3NlcyA9IGNzc1BhcnRzWzBdLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBjb25zdCBjc3NQcm9wcyA9IGNzc1BhcnRzWzFdLnNwbGl0KCc7Jyk7XG4gICAgICAgICAgICBjc3NDbGFzc2VzLmZvckVhY2goKF8pPT57XG4gICAgICAgICAgICAgICAgY29uc3QgY3NzQ2xhc3MgPSBfLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNzc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBkb2N1bWVudC5zdHlsZXNbY3NzQ2xhc3NdIHx8IHt9O1xuICAgICAgICAgICAgICAgIGNzc1Byb3BzLmZvckVhY2goKGNzc1Byb3ApPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBjc3NQcm9wLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNzc1Byb3Auc3Vic3RyKDAsIHByb3ApLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjc3NQcm9wLnN1YnN0cihwcm9wICsgMSwgY3NzUHJvcC5sZW5ndGggLSBwcm9wKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuc3R5bGVzW2Nzc0NsYXNzXSA9IHByb3BzO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnN0eWxlc1NwZWNpZmljaXR5W2Nzc0NsYXNzXSA9IGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoY3NzQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGlmIChjc3NDbGFzcyA9PT0gJ0Bmb250LWZhY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRGYW1pbHkgPSBwcm9wc1snZm9udC1mYW1pbHknXS5nZXRTdHJpbmcoKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjcyA9IHByb3BzLnNyYy5nZXRTdHJpbmcoKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICBzcmNzLmZvckVhY2goKHNyYyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmMuaW5kZXhPZignZm9ybWF0KFwic3ZnXCIpJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gcGFyc2VFeHRlcm5hbFVybChzcmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCBuZXcgU1ZHRm9udExvYWRlcihkb2N1bWVudCkubG9hZChmb250RmFtaWx5LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblN0eWxlRWxlbWVudC5wYXJzZUV4dGVybmFsVXJsID0gcGFyc2VFeHRlcm5hbFVybDtcblxuY2xhc3MgVXNlRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gICAgc2V0Q29udGV4dChjdHgpIHtcbiAgICAgICAgc3VwZXIuc2V0Q29udGV4dChjdHgpO1xuICAgICAgICBjb25zdCB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGNvbnN0IHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcbiAgICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeEF0dHIuZ2V0UGl4ZWxzKCd4JyksIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIHlBdHRyLmdldFBpeGVscygneScpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoKGN0eCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5wYXRoKGN0eCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgLCBlbGVtZW50ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCB0ZW1wU3ZnID0gZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50IGluIHN5bWJvbCBjYXNlcyAoaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3N0cnVjdC5odG1sI1VzZUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgdGVtcFN2ZyA9IG5ldyBTVkdFbGVtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ZpZXdCb3gnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMucHJlc2VydmVBc3BlY3RSYXRpbyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMub3ZlcmZsb3cgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvdmVyZmxvdycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvdmVyZmxvdycpLmdldFN0cmluZygpKTtcbiAgICAgICAgICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIHN0aWxsIHRoZSBwYXJlbnQgb2YgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZXMub3BhY2l0eSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ29wYWNpdHknLCB0aGlzLmNhbGN1bGF0ZU9wYWNpdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcFN2Zy50eXBlID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoU3R5bGUgPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd3aWR0aCcsIHdpZHRoU3R5bGUuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0JywgaGVpZ2h0U3R5bGUuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZFBhcmVudCA9IHRlbXBTdmcucGFyZW50O1xuICAgICAgICAgICAgdGVtcFN2Zy5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGVtcFN2Zy5yZW5kZXIoY3R4KTtcbiAgICAgICAgICAgIHRlbXBTdmcucGFyZW50ID0gb2xkUGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxlbWVudFRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIGVsZW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkRWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWRFbGVtZW50O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICd1c2UnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSkge1xuICAgIHJldHVybiBpbWdbeSAqIHdpZHRoICogNCArIHggKiA0ICsgcmdiYV07XG59XG5mdW5jdGlvbiBpbVNldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhLCB2YWwpIHtcbiAgICBpbWdbeSAqIHdpZHRoICogNCArIHggKiA0ICsgcmdiYV0gPSB2YWw7XG59XG5mdW5jdGlvbiBtKG1hdHJpeCwgaSwgdikge1xuICAgIGNvbnN0IG1pID0gbWF0cml4W2ldO1xuICAgIHJldHVybiBtaSAqIHY7XG59XG5mdW5jdGlvbiBjKGEsIG0xLCBtMiwgbTMpIHtcbiAgICByZXR1cm4gbTEgKyBNYXRoLmNvcyhhKSAqIG0yICsgTWF0aC5zaW4oYSkgKiBtMztcbn1cbmNsYXNzIEZlQ29sb3JNYXRyaXhFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoY3R4LCBfeCwgX3ksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gYXNzdW1pbmcgeD09MCAmJiB5PT0wIGZvciBub3dcbiAgICAgICAgY29uc3QgeyBpbmNsdWRlT3BhY2l0eSAsIG1hdHJpeCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNyY0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBmb3IobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5Kyspe1xuICAgICAgICAgICAgZm9yKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4Kyspe1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMpO1xuICAgICAgICAgICAgICAgIGxldCBuciA9IG0obWF0cml4LCAwLCByKSArIG0obWF0cml4LCAxLCBnKSArIG0obWF0cml4LCAyLCBiKSArIG0obWF0cml4LCAzLCBhKSArIG0obWF0cml4LCA0LCAxKTtcbiAgICAgICAgICAgICAgICBsZXQgbmcgPSBtKG1hdHJpeCwgNSwgcikgKyBtKG1hdHJpeCwgNiwgZykgKyBtKG1hdHJpeCwgNywgYikgKyBtKG1hdHJpeCwgOCwgYSkgKyBtKG1hdHJpeCwgOSwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IG5iID0gbShtYXRyaXgsIDEwLCByKSArIG0obWF0cml4LCAxMSwgZykgKyBtKG1hdHJpeCwgMTIsIGIpICsgbShtYXRyaXgsIDEzLCBhKSArIG0obWF0cml4LCAxNCwgMSk7XG4gICAgICAgICAgICAgICAgbGV0IG5hID0gbShtYXRyaXgsIDE1LCByKSArIG0obWF0cml4LCAxNiwgZykgKyBtKG1hdHJpeCwgMTcsIGIpICsgbShtYXRyaXgsIDE4LCBhKSArIG0obWF0cml4LCAxOSwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbmcgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuYiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5hICo9IGEgLyAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCwgbnIpO1xuICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSwgbmcpO1xuICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMiwgbmIpO1xuICAgICAgICAgICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMywgbmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEoc3JjRGF0YSwgMCwgMCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKXtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnZmVDb2xvck1hdHJpeCc7XG4gICAgICAgIGxldCBtYXRyaXggPSB0b051bWJlcnModGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpLmdldFN0cmluZygpKTtcbiAgICAgICAgc3dpdGNoKHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykuZ2V0U3RyaW5nKCdtYXRyaXgnKSl7XG4gICAgICAgICAgICBjYXNlICdzYXR1cmF0ZSc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gbWF0cml4WzBdO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi8gbWF0cml4ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgMC4yMTMgKyAwLjc4NyAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjcxNSAtIDAuNzE1ICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMDcyIC0gMC4wNzIgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjIxMyAtIDAuMjEzICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNzE1ICsgMC4yODUgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4wNzIgLSAwLjA3MiAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjEzIC0gMC4yMTMgKiBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC43MTUgLSAwLjcxNSAqIHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjA3MiArIDAuOTI4ICogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdodWVSb3RhdGUnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IG1hdHJpeFswXSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqLyBtYXRyaXggPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuMjEzLCAwLjc4NywgLTAuMjEzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC43MTUsIC0wLjcxNSwgLTAuNzE1KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC4wNzIsIC0wLjA3MiwgMC45MjgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuMjEzLCAtMC4yMTMsIDAuMTQzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC43MTUsIDAuMjg1LCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMoYSwgMC4wNzIsIC0wLjA3MiwgLTAuMjgzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjIxMywgLTAuMjEzLCAtMC43ODcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyhhLCAwLjcxNSwgLTAuNzE1LCAwLjcxNSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjKGEsIDAuMDcyLCAwLjkyOCwgMC4wNzIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2x1bWluYW5jZVRvQWxwaGEnOlxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqLyBtYXRyaXggPSBbXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAuMjEyNSxcbiAgICAgICAgICAgICAgICAgICAgMC43MTU0LFxuICAgICAgICAgICAgICAgICAgICAwLjA3MjEsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgICAgICB0aGlzLmluY2x1ZGVPcGFjaXR5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2luY2x1ZGVPcGFjaXR5JykuaGFzVmFsdWUoKTtcbiAgICB9XG59XG5cbmNsYXNzIE1hc2tFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoY3R4LCBlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgZG9jdW1lbnQgIH0gPSB0aGlzO1xuICAgICAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmdcbiAgICAgICAgbGV0IHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgICAgICBsZXQgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIGxldCBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgICAgaWYgKCF3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueDEpO1xuICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueTEpO1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICAgICAgY29uc3QgbWFza0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjb25zdCBtYXNrQ3R4ID0gbWFza0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHMobWFza0N0eCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4obWFza0N0eCk7XG4gICAgICAgIC8vIGNvbnZlcnQgbWFzayB0byBhbHBoYSB3aXRoIGEgZmFrZSBub2RlXG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG91dCBhcHBseSBmcm9tIGZlQ29sb3JNYXRyaXhcbiAgICAgICAgbmV3IEZlQ29sb3JNYXRyaXhFbGVtZW50KGRvY3VtZW50LCB7XG4gICAgICAgICAgICBub2RlVHlwZTogMSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdsdW1pbmFuY2VUb0FscGhhJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogJ2luY2x1ZGVPcGFjaXR5JyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSkuYXBwbHkobWFza0N0eCwgMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICAgICAgZWxlbWVudC5yZW5kZXIodG1wQ3R4KTtcbiAgICAgICAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSBtYXNrQ3R4LmNyZWF0ZVBhdHRlcm4obWFza0NhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgICAgICB0bXBDdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRtcEN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgLy8gcmVhc3NpZ24gbWFza1xuICAgICAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gICAgfVxuICAgIHJlbmRlcihfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ21hc2snO1xuICAgIH1cbn1cbk1hc2tFbGVtZW50Lmlnbm9yZVN0eWxlcyA9IFtcbiAgICAnbWFzaycsXG4gICAgJ3RyYW5zZm9ybScsXG4gICAgJ2NsaXAtcGF0aCdcbl07XG5cbmNvbnN0IG5vb3AgPSAoKT0+e1xuLy8gTk9PUFxufTtcbmNsYXNzIENsaXBQYXRoRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KGN0eCkge1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY29udGV4dFByb3RvID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihjdHgpO1xuICAgICAgICBjb25zdCB7IGJlZ2luUGF0aCAsIGNsb3NlUGF0aCAgfSA9IGN0eDtcbiAgICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICAgICAgY29udGV4dFByb3RvLmJlZ2luUGF0aCA9IG5vb3A7XG4gICAgICAgICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBSZWZsZWN0LmFwcGx5KGJlZ2luUGF0aCwgY3R4LCBbXSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICBpZiAoISgncGF0aCcgaW4gY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybSA9ICdlbGVtZW50VHJhbnNmb3JtJyBpbiBjaGlsZCA/IGNoaWxkLmVsZW1lbnRUcmFuc2Zvcm0oKSA6IG51bGwgLy8gaGFuZGxlIDx1c2UgLz5cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5wYXRoKGN0eCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0udW5hcHBseShjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgUmVmbGVjdC5hcHBseShjbG9zZVBhdGgsIGN0eCwgW10pO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gYmVnaW5QYXRoO1xuICAgICAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IGNsb3NlUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoXykge1xuICAgIC8vIE5PIFJFTkRFUlxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdjbGlwUGF0aCc7XG4gICAgfVxufVxuXG5jbGFzcyBGaWx0ZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgYXBwbHkoY3R4LCBlbGVtZW50KSB7XG4gICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wIHN2Z1xuICAgICAgICBjb25zdCB7IGRvY3VtZW50ICwgY2hpbGRyZW4gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9ICdnZXRCb3VuZGluZ0JveCcgaW4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KSA6IG51bGw7XG4gICAgICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHggPSAwO1xuICAgICAgICBsZXQgcHkgPSAwO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCk9PntcbiAgICAgICAgICAgIGNvbnN0IGVmZCA9IGNoaWxkLmV4dHJhRmlsdGVyRGlzdGFuY2UgfHwgMDtcbiAgICAgICAgICAgIHB4ID0gTWF0aC5tYXgocHgsIGVmZCk7XG4gICAgICAgICAgICBweSA9IE1hdGgubWF4KHB5LCBlZmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgICAgICBjb25zdCB0bXBDYW52YXNXaWR0aCA9IHdpZHRoICsgMiAqIHB4O1xuICAgICAgICBjb25zdCB0bXBDYW52YXNIZWlnaHQgPSBoZWlnaHQgKyAyICogcHk7XG4gICAgICAgIGlmICh0bXBDYW52YXNXaWR0aCA8IDEgfHwgdG1wQ2FudmFzSGVpZ2h0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngpO1xuICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55KTtcbiAgICAgICAgY29uc3QgaWdub3JlZFN0eWxlcyA9IHRoaXMucmVtb3ZlU3R5bGVzKGVsZW1lbnQsIEZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICAgICAgY29uc3QgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgICAgIHRtcEN0eC50cmFuc2xhdGUoLXggKyBweCwgLXkgKyBweSk7XG4gICAgICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7XG4gICAgICAgIC8vIGFwcGx5IGZpbHRlcnNcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpPT57XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkLmFwcGx5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYXBwbHkodG1wQ3R4LCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHJlbmRlciBvbiBtZVxuICAgICAgICBjdHguZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCwgeCAtIHB4LCB5IC0gcHksIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgICAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gICAgfVxuICAgIHJlbmRlcihfKSB7XG4gICAgLy8gTk8gUkVOREVSXG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZpbHRlcic7XG4gICAgfVxufVxuRmlsdGVyRWxlbWVudC5pZ25vcmVTdHlsZXMgPSBbXG4gICAgJ2ZpbHRlcicsXG4gICAgJ3RyYW5zZm9ybScsXG4gICAgJ2NsaXAtcGF0aCdcbl07XG5cbmNsYXNzIEZlRHJvcFNoYWRvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkge1xuICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyl7XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZlRHJvcFNoYWRvdyc7XG4gICAgICAgIHRoaXMuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICAgIH1cbn1cblxuY2xhc3MgRmVNb3JwaG9sb2d5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICAgIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2ZlTW9ycGhvbG9neSc7XG4gICAgfVxufVxuXG5jbGFzcyBGZUNvbXBvc2l0ZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkge1xuICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmZUNvbXBvc2l0ZSc7XG4gICAgfVxufVxuXG5jbGFzcyBGZUdhdXNzaWFuQmx1ckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBhcHBseShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudCAsIGJsdXJSYWRpdXMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQud2luZG93ID8gZG9jdW1lbnQud2luZG93LmRvY3VtZW50LmJvZHkgOiBudWxsO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgICAgICAvLyBTdGFja0JsdXIgcmVxdWlyZXMgY2FudmFzIGJlIG9uIGRvY3VtZW50XG4gICAgICAgIGNhbnZhcy5pZCA9IGRvY3VtZW50LmdldFVuaXF1ZUlkKCk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXNSR0JBKGNhbnZhcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgYmx1clJhZGl1cyk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpe1xuICAgICAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdmZUdhdXNzaWFuQmx1cic7XG4gICAgICAgIHRoaXMuYmx1clJhZGl1cyA9IE1hdGguZmxvb3IodGhpcy5nZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicpLmdldE51bWJlcigpKTtcbiAgICAgICAgdGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gdGhpcy5ibHVyUmFkaXVzO1xuICAgIH1cbn1cblxuY2xhc3MgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnR5cGUgPSAndGl0bGUnO1xuICAgIH1cbn1cblxuY2xhc3MgRGVzY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMudHlwZSA9ICdkZXNjJztcbiAgICB9XG59XG5cbmNvbnN0IGVsZW1lbnRzID0ge1xuICAgICdzdmcnOiBTVkdFbGVtZW50LFxuICAgICdyZWN0JzogUmVjdEVsZW1lbnQsXG4gICAgJ2NpcmNsZSc6IENpcmNsZUVsZW1lbnQsXG4gICAgJ2VsbGlwc2UnOiBFbGxpcHNlRWxlbWVudCxcbiAgICAnbGluZSc6IExpbmVFbGVtZW50LFxuICAgICdwb2x5bGluZSc6IFBvbHlsaW5lRWxlbWVudCxcbiAgICAncG9seWdvbic6IFBvbHlnb25FbGVtZW50LFxuICAgICdwYXRoJzogUGF0aEVsZW1lbnQsXG4gICAgJ3BhdHRlcm4nOiBQYXR0ZXJuRWxlbWVudCxcbiAgICAnbWFya2VyJzogTWFya2VyRWxlbWVudCxcbiAgICAnZGVmcyc6IERlZnNFbGVtZW50LFxuICAgICdsaW5lYXJHcmFkaWVudCc6IExpbmVhckdyYWRpZW50RWxlbWVudCxcbiAgICAncmFkaWFsR3JhZGllbnQnOiBSYWRpYWxHcmFkaWVudEVsZW1lbnQsXG4gICAgJ3N0b3AnOiBTdG9wRWxlbWVudCxcbiAgICAnYW5pbWF0ZSc6IEFuaW1hdGVFbGVtZW50LFxuICAgICdhbmltYXRlQ29sb3InOiBBbmltYXRlQ29sb3JFbGVtZW50LFxuICAgICdhbmltYXRlVHJhbnNmb3JtJzogQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsXG4gICAgJ2ZvbnQnOiBGb250RWxlbWVudCxcbiAgICAnZm9udC1mYWNlJzogRm9udEZhY2VFbGVtZW50LFxuICAgICdtaXNzaW5nLWdseXBoJzogTWlzc2luZ0dseXBoRWxlbWVudCxcbiAgICAnZ2x5cGgnOiBHbHlwaEVsZW1lbnQsXG4gICAgJ3RleHQnOiBUZXh0RWxlbWVudCxcbiAgICAndHNwYW4nOiBUU3BhbkVsZW1lbnQsXG4gICAgJ3RyZWYnOiBUUmVmRWxlbWVudCxcbiAgICAnYSc6IEFFbGVtZW50LFxuICAgICd0ZXh0UGF0aCc6IFRleHRQYXRoRWxlbWVudCxcbiAgICAnaW1hZ2UnOiBJbWFnZUVsZW1lbnQsXG4gICAgJ2cnOiBHRWxlbWVudCxcbiAgICAnc3ltYm9sJzogU3ltYm9sRWxlbWVudCxcbiAgICAnc3R5bGUnOiBTdHlsZUVsZW1lbnQsXG4gICAgJ3VzZSc6IFVzZUVsZW1lbnQsXG4gICAgJ21hc2snOiBNYXNrRWxlbWVudCxcbiAgICAnY2xpcFBhdGgnOiBDbGlwUGF0aEVsZW1lbnQsXG4gICAgJ2ZpbHRlcic6IEZpbHRlckVsZW1lbnQsXG4gICAgJ2ZlRHJvcFNoYWRvdyc6IEZlRHJvcFNoYWRvd0VsZW1lbnQsXG4gICAgJ2ZlTW9ycGhvbG9neSc6IEZlTW9ycGhvbG9neUVsZW1lbnQsXG4gICAgJ2ZlQ29tcG9zaXRlJzogRmVDb21wb3NpdGVFbGVtZW50LFxuICAgICdmZUNvbG9yTWF0cml4JzogRmVDb2xvck1hdHJpeEVsZW1lbnQsXG4gICAgJ2ZlR2F1c3NpYW5CbHVyJzogRmVHYXVzc2lhbkJsdXJFbGVtZW50LFxuICAgICd0aXRsZSc6IFRpdGxlRWxlbWVudCxcbiAgICAnZGVzYyc6IERlc2NFbGVtZW50XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUltYWdlKHNyYykge1xuICAgIGxldCBhbm9ueW1vdXNDcm9zc09yaWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBpZiAoYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGltYWdlLm9ubG9hZCA9ICgpPT57XG4gICAgICAgICAgICByZXNvbHZlKGltYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IChfZXZlbnQsIF9zb3VyY2UsIF9saW5lbm8sIF9jb2xubywgZXJyb3IpPT57XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG4gICAgfSk7XG59XG5jb25zdCBERUZBVUxUX0VNX1NJWkUgPSAxMjtcbmNsYXNzIERvY3VtZW50IHtcbiAgICBiaW5kQ3JlYXRlSW1hZ2UoY3JlYXRlSW1hZ2UxLCBhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgICAgICBpZiAodHlwZW9mIGFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiAoc291cmNlLCBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luKT0+Y3JlYXRlSW1hZ2UxKHNvdXJjZSwgdHlwZW9mIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJyA/IGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gOiBhbm9ueW1vdXNDcm9zc09yaWdpbilcbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2UxO1xuICAgIH1cbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4ud2luZG93O1xuICAgIH1cbiAgICBnZXQgZmV0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5mZXRjaDtcbiAgICB9XG4gICAgZ2V0IGN0eCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmN0eDtcbiAgICB9XG4gICAgZ2V0IGVtU2l6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBlbVNpemVTdGFjayAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBlbVNpemVTdGFja1tlbVNpemVTdGFjay5sZW5ndGggLSAxXSB8fCBERUZBVUxUX0VNX1NJWkU7XG4gICAgfVxuICAgIHNldCBlbVNpemUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBlbVNpemVTdGFjayAgfSA9IHRoaXM7XG4gICAgICAgIGVtU2l6ZVN0YWNrLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBwb3BFbVNpemUoKSB7XG4gICAgICAgIGNvbnN0IHsgZW1TaXplU3RhY2sgIH0gPSB0aGlzO1xuICAgICAgICBlbVNpemVTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgZ2V0VW5pcXVlSWQoKSB7XG4gICAgICAgIHJldHVybiBcImNhbnZnXCIuY29uY2F0KCsrdGhpcy51bmlxdWVJZCk7XG4gICAgfVxuICAgIGlzSW1hZ2VzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXMuZXZlcnkoKF8pPT5fLmxvYWRlZFxuICAgICAgICApO1xuICAgIH1cbiAgICBpc0ZvbnRzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250cy5ldmVyeSgoXyk9Pl8ubG9hZGVkXG4gICAgICAgICk7XG4gICAgfVxuICAgIGNyZWF0ZURvY3VtZW50RWxlbWVudChkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50LnJvb3QgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICAgICAgICB0aGlzLmRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgY3JlYXRlRWxlbWVudChub2RlKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUeXBlID0gbm9kZS5ub2RlTmFtZS5yZXBsYWNlKC9eW146XSs6LywgJycpO1xuICAgICAgICBjb25zdCBFbGVtZW50VHlwZSA9IERvY3VtZW50LmVsZW1lbnRUeXBlc1tlbGVtZW50VHlwZV07XG4gICAgICAgIGlmIChFbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50VHlwZSh0aGlzLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVua25vd25FbGVtZW50KHRoaXMsIG5vZGUpO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcywgbm9kZSk7XG4gICAgfVxuICAgIHNldFZpZXdCb3goY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc2NyZWVuLnNldFZpZXdCb3goe1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHRoaXMsXG4gICAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNhbnZnLCB7IHJvb3RFbVNpemUgPURFRkFVTFRfRU1fU0laRSAsIGVtU2l6ZSA9REVGQVVMVF9FTV9TSVpFICwgY3JlYXRlQ2FudmFzOiBjcmVhdGVDYW52YXMxID0gRG9jdW1lbnQuY3JlYXRlQ2FudmFzICwgY3JlYXRlSW1hZ2U6IGNyZWF0ZUltYWdlMiA9IERvY3VtZW50LmNyZWF0ZUltYWdlICwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gIH0gPSB7fSl7XG4gICAgICAgIHRoaXMuY2FudmcgPSBjYW52ZztcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgICB0aGlzLnN0eWxlc1NwZWNpZmljaXR5ID0ge307XG4gICAgICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgICAgIHRoaXMuZm9udHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbVNpemVTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLnVuaXF1ZUlkID0gMDtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBjYW52Zy5zY3JlZW47XG4gICAgICAgIHRoaXMucm9vdEVtU2l6ZSA9IHJvb3RFbVNpemU7XG4gICAgICAgIHRoaXMuZW1TaXplID0gZW1TaXplO1xuICAgICAgICB0aGlzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhczE7XG4gICAgICAgIHRoaXMuY3JlYXRlSW1hZ2UgPSB0aGlzLmJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZTIsIGFub255bW91c0Nyb3NzT3JpZ2luKTtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2FpdCgoKT0+dGhpcy5pc0ltYWdlc0xvYWRlZCgpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2NyZWVuLndhaXQoKCk9PnRoaXMuaXNGb250c0xvYWRlZCgpXG4gICAgICAgICk7XG4gICAgfVxufVxuRG9jdW1lbnQuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzO1xuRG9jdW1lbnQuY3JlYXRlSW1hZ2UgPSBjcmVhdGVJbWFnZTtcbkRvY3VtZW50LmVsZW1lbnRUeXBlcyA9IGVsZW1lbnRzO1xuXG4vKipcbiAqIFNWRyByZW5kZXJlciBvbiBjYW52YXMuXG4gKi8gY2xhc3MgQ2Fudmcge1xuICAgIC8qKlxuICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nIG9yIFVSTC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXG4gICAqLyBzdGF0aWMgYXN5bmMgZnJvbShjdHgsIHN2Zykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHN2Z0RvY3VtZW50ID0gYXdhaXQgcGFyc2VyLnBhcnNlKHN2Zyk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZy5cbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxuICAgKi8gc3RhdGljIGZyb21TdHJpbmcoY3R4LCBzdmcpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdmdEb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3ZnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYW52ZyhjdHgsIHN2Z0RvY3VtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cbiAgICovIGZvcmsoY3R4LCBzdmcpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgICByZXR1cm4gQ2FudmcuZnJvbShjdHgsIHN2Zywge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIENhbnZnIGluc3RhbmNlLlxuICAgKi8gZm9ya1N0cmluZyhjdHgsIHN2Zykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICAgIHJldHVybiBDYW52Zy5mcm9tU3RyaW5nKGN0eCwgc3ZnLCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogRG9jdW1lbnQgaXMgcmVhZHkgcHJvbWlzZS5cbiAgICogQHJldHVybnMgUmVhZHkgcHJvbWlzZS5cbiAgICovIHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4ucmVhZHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIERvY3VtZW50IGlzIHJlYWR5IHZhbHVlLlxuICAgKiBAcmV0dXJucyBJcyByZWFkeSBvciBub3QuXG4gICAqLyBpc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaXNSZWFkeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVuZGVyIG9ubHkgZmlyc3QgZnJhbWUsIGlnbm9yaW5nIGFuaW1hdGlvbnMgYW5kIG1vdXNlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxuICAgKi8gYXN5bmMgcmVuZGVyKCkge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHRoaXMuc3RhcnQoe1xuICAgICAgICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlLFxuICAgICAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnJlYWR5KCk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogU3RhcnQgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlciBvcHRpb25zLlxuICAgKi8gc3RhcnQoKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQgLCBzY3JlZW4gLCBvcHRpb25zOiBiYXNlT3B0aW9ucyAgfSA9IHRoaXM7XG4gICAgICAgIHNjcmVlbi5zdGFydChkb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZSxcbiAgICAgICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFN0b3AgcmVuZGVyaW5nLlxuICAgKi8gc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zY3JlZW4uc3RvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogUmVzaXplIFNWRyB0byBmaXQgaW4gZ2l2ZW4gc2l6ZS5cbiAgICogQHBhcmFtIHdpZHRoXG4gICAqIEBwYXJhbSBoZWlnaHRcbiAgICogQHBhcmFtIHByZXNlcnZlQXNwZWN0UmF0aW9cbiAgICovIHJlc2l6ZSh3aWR0aCkge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB2b2lkIDAgPyBhcmd1bWVudHNbMV0gOiB3aWR0aCwgcHJlc2VydmVBc3BlY3RSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIE1haW4gY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBEb2N1bWVudC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cbiAgICovIGNvbnN0cnVjdG9yKGN0eCwgc3ZnLCBvcHRpb25zID0ge30pe1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbihjdHgsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IG5ldyBEb2N1bWVudCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRFbGVtZW50KHN2Zyk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBRWxlbWVudCwgQW5pbWF0ZUNvbG9yRWxlbWVudCwgQW5pbWF0ZUVsZW1lbnQsIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LCBCb3VuZGluZ0JveCwgQ0IxLCBDQjIsIENCMywgQ0I0LCBDYW52ZywgQ2lyY2xlRWxlbWVudCwgQ2xpcFBhdGhFbGVtZW50LCBEZWZzRWxlbWVudCwgRGVzY0VsZW1lbnQsIERvY3VtZW50LCBFbGVtZW50LCBFbGxpcHNlRWxlbWVudCwgRmVDb2xvck1hdHJpeEVsZW1lbnQsIEZlQ29tcG9zaXRlRWxlbWVudCwgRmVEcm9wU2hhZG93RWxlbWVudCwgRmVHYXVzc2lhbkJsdXJFbGVtZW50LCBGZU1vcnBob2xvZ3lFbGVtZW50LCBGaWx0ZXJFbGVtZW50LCBGb250LCBGb250RWxlbWVudCwgRm9udEZhY2VFbGVtZW50LCBHRWxlbWVudCwgR2x5cGhFbGVtZW50LCBHcmFkaWVudEVsZW1lbnQsIEltYWdlRWxlbWVudCwgTGluZUVsZW1lbnQsIExpbmVhckdyYWRpZW50RWxlbWVudCwgTWFya2VyRWxlbWVudCwgTWFza0VsZW1lbnQsIE1hdHJpeCwgTWlzc2luZ0dseXBoRWxlbWVudCwgTW91c2UsIFBTRVVET19aRVJPLCBQYXJzZXIsIFBhdGhFbGVtZW50LCBQYXRoUGFyc2VyLCBQYXR0ZXJuRWxlbWVudCwgUG9pbnQsIFBvbHlnb25FbGVtZW50LCBQb2x5bGluZUVsZW1lbnQsIFByb3BlcnR5LCBRQjEsIFFCMiwgUUIzLCBSYWRpYWxHcmFkaWVudEVsZW1lbnQsIFJlY3RFbGVtZW50LCBSZW5kZXJlZEVsZW1lbnQsIFJvdGF0ZSwgU1ZHRWxlbWVudCwgU1ZHRm9udExvYWRlciwgU2NhbGUsIFNjcmVlbiwgU2tldywgU2tld1gsIFNrZXdZLCBTdG9wRWxlbWVudCwgU3R5bGVFbGVtZW50LCBTeW1ib2xFbGVtZW50LCBUUmVmRWxlbWVudCwgVFNwYW5FbGVtZW50LCBUZXh0RWxlbWVudCwgVGV4dFBhdGhFbGVtZW50LCBUaXRsZUVsZW1lbnQsIFRyYW5zZm9ybSwgVHJhbnNsYXRlLCBVbmtub3duRWxlbWVudCwgVXNlRWxlbWVudCwgVmlld1BvcnQsIGNvbXByZXNzU3BhY2VzLCBlbGVtZW50cywgZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eSwgbm9ybWFsaXplQXR0cmlidXRlTmFtZSwgbm9ybWFsaXplQ29sb3IsIHBhcnNlRXh0ZXJuYWxVcmwsIGluZGV4IGFzIHByZXNldHMsIHRvTWF0cml4VmFsdWUsIHRvTnVtYmVycywgdHJpbUxlZnQsIHRyaW1SaWdodCwgdmVjdG9yTWFnbml0dWRlLCB2ZWN0b3JzQW5nbGUsIHZlY3RvcnNSYXRpbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/dist/index.js\n");

/***/ })

};
;